<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/png" href="/favicon.png">
  <title>Orbital Compute Economics</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Load shared model via ES module -->
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    :root {
      --bg: #f7f7f7; --surface: #ffffff; --surface2: #f0f0f0; --surface3: #e5e5e5;
      --border: #d0d0d0; --text: #1a1a1a; --muted: #666666;
      --orbital: #0066cc; --ground: #cc3333; --accent: #0066cc; --warning: #cc8800;
      --purple: #6633cc; --orange: #cc6600; --pink: #cc3366;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; background: var(--bg); color: var(--text); font-size: 13px; -webkit-font-smoothing: antialiased; }
    .app { display: grid; grid-template-columns: 280px 1fr; min-height: 100vh; }
    .sidebar { background: var(--surface); border-right: 1px solid var(--border); position: sticky; top: 0; height: 100vh; overflow-y: auto; }
    .main { display: flex; flex-direction: column; min-width: 0; }
    .sidebar-header { padding: 16px; border-bottom: 1px solid var(--border); position: sticky; top: 0; background: var(--surface); z-index: 10; border-left: 3px solid var(--orbital); }
    .sidebar-title { font-size: 13px; font-weight: 600; display: flex; align-items: center; gap: 8px; letter-spacing: -0.01em; }
    .sidebar-title .badge { font-size: 9px; background: var(--orbital); color: white; padding: 2px 6px; border-radius: 3px; font-weight: 600; letter-spacing: 0.02em; }
    .sidebar-subtitle { font-size: 11px; color: var(--muted); margin-top: 4px; }
    .sidebar-content { padding: 12px; }
    .section { background: var(--surface2); border-radius: 4px; padding: 12px; margin-bottom: 12px; border: 1px solid var(--border); }
    .derived-section { background: var(--surface2); border-radius: 4px; padding: 12px; margin-bottom: 12px; border: 1px solid var(--border); }
    .derived-section summary { cursor: pointer; font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: var(--muted); }
    .derived-section summary::before { content: ''; width: 2px; height: 10px; background: var(--accent); display: inline-block; margin-right: 8px; vertical-align: middle; }
    .derived-grid { display: flex; flex-direction: column; gap: 8px; margin-top: 10px; }
    .derived-item { display: flex; flex-direction: column; padding: 6px; background: var(--surface); border-radius: 3px; border: 1px solid var(--border); }
    .derived-label { font-size: 9px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.03em; }
    .derived-value { font-size: 14px; font-weight: 600; color: var(--text); font-variant-numeric: tabular-nums; }
    .derived-unit { font-size: 10px; color: var(--muted); }
    .section-title { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: var(--muted); margin-bottom: 10px; display: flex; align-items: center; gap: 6px; }
    .section-title::before { content: ''; width: 2px; height: 10px; background: var(--orbital); }
    .section-title.ground::before { background: var(--ground); }
    .slider-val.ground { color: var(--ground); }
    input[type="range"].ground::-webkit-slider-thumb { background: var(--ground); }
    .slider-row { margin-bottom: 10px; }
    .slider-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
    .slider-lbl { font-size: 11px; }
    .slider-val { font-size: 12px; font-weight: 600; color: var(--orbital); font-variant-numeric: tabular-nums; }
    .slider-val .unit { color: var(--muted); font-size: 10px; margin-left: 2px; font-weight: 400; }
    input[type="range"] { width: 100%; height: 4px; background: var(--border); border-radius: 2px; appearance: none; cursor: pointer; }
    input[type="range"]::-webkit-slider-thumb { appearance: none; width: 12px; height: 12px; border-radius: 50%; background: var(--orbital); border: 2px solid var(--surface); box-shadow: 0 1px 2px rgba(0,0,0,0.15); }
    .toggle-row { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid var(--border); }
    .toggle-row:last-child { border-bottom: none; }
    .toggle-lbl { font-size: 11px; }
    .toggle-group { display: flex; align-items: center; gap: 8px; }
    .toggle { position: relative; width: 34px; height: 18px; }
    .toggle input { opacity: 0; width: 0; height: 0; }
    .toggle-track { position: absolute; cursor: pointer; inset: 0; background: var(--border); border-radius: 9px; transition: 0.2s; }
    .toggle-track::before { position: absolute; content: ""; height: 12px; width: 12px; left: 3px; bottom: 3px; background: var(--surface); border-radius: 50%; transition: 0.2s; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
    .toggle input:checked + .toggle-track { background: var(--orbital); }
    .toggle input:checked + .toggle-track::before { transform: translateX(16px); background: white; }
    .year-input { width: 58px; background: var(--surface); border: 1px solid var(--border); border-radius: 3px; color: var(--orbital); font-family: inherit; font-size: 11px; font-weight: 600; padding: 3px 6px; text-align: center; font-variant-numeric: tabular-nums; }
    .year-input:disabled { opacity: 0.4; }
    .toggle-effect { font-size: 9px; color: var(--muted); margin-top: 2px; }
    .toggle-effect.active { color: var(--orbital); }
    .main { display: flex; flex-direction: column; overflow: hidden; }
    .main-header { padding: 12px 16px; border-bottom: 1px solid var(--border); background: var(--surface); display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 8px; }
    .tabs { display: flex; gap: 4px; flex-wrap: wrap; }
    .tab { padding: 8px 14px; background: transparent; border: 1px solid transparent; border-radius: 4px; color: var(--muted); font-size: 10px; font-weight: 600; cursor: pointer; transition: all 0.2s; text-transform: uppercase; letter-spacing: 0.05em; }
    .tab:hover { background: var(--surface2); color: var(--text); }
    .tab.active { background: var(--orbital); color: white; }
    .header-badges { display: flex; gap: 12px; flex-wrap: wrap; }
    .badge-item { display: flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--surface2); border-radius: 4px; border: 1px solid var(--border); }
    .badge-label { font-size: 9px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.03em; }
    .badge-value { font-size: 13px; font-weight: 600; font-variant-numeric: tabular-nums; }
    .badge-value.orbital { color: var(--orbital); }
    .badge-value.warning { color: var(--warning); }
    .main-content { flex: 1; overflow-y: auto; padding: 16px; }
    .tab-panel { display: none; }
    .tab-panel.active { display: block; }
    .kpis { display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 10px; margin-bottom: 16px; }
    .kpi { 
      background: linear-gradient(180deg, var(--surface) 0%, var(--surface2) 100%);
      border: 1px solid var(--border); 
      border-radius: 4px; 
      padding: 12px;
      border-top: 2px solid var(--orbital);
    }
    .kpi-label { font-size: 9px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.03em; }
    .kpi-value { font-size: 20px; font-weight: 700; margin-top: 4px; font-variant-numeric: tabular-nums; }
    .kpi.orbital .kpi-value { color: var(--orbital); }
    .kpi.ground .kpi-value { color: var(--ground); }
    .kpi.accent .kpi-value { color: var(--accent); }
    .kpi.warning .kpi-value { color: var(--warning); }
    .kpi.purple .kpi-value { color: var(--purple); }
    .kpi.orbital { border-top-color: var(--orbital); }
    .kpi.ground { border-top-color: var(--ground); }
    .kpi.accent { border-top-color: var(--accent); }
    .kpi.warning { border-top-color: var(--warning); }
    .kpi.purple { border-top-color: var(--purple); }
    .charts { display: flex; flex-direction: column; gap: 12px; }
    .chart-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 14px;
      min-width: 0;
      box-shadow: 0 1px 3px rgba(0,0,0,0.04);
    }
    .chart-card:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.08); }
    /* All charts same size - wide class no longer spans multiple columns */
    .chart-card.wide { grid-column: span 1; }
    .chart-header { margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid var(--border); }
    .chart-title { font-size: 11px; font-weight: 600; }
    .chart-desc { font-size: 10px; color: var(--muted); margin-top: 2px; }
    .chart-box { height: 250px; min-width: 0; }
    /* All charts same height - tall class ignored */
    .chart-card.tall .chart-box { height: 250px; }
    .legend { display: flex; flex-wrap: wrap; gap: 12px; margin-top: 8px; }
    .legend-item { display: flex; align-items: center; gap: 5px; font-size: 10px; color: var(--muted); }
    .legend-dot { width: 10px; height: 10px; border-radius: 2px; }
    .sla-note { font-size: 10px; color: var(--muted); margin-top: 4px; }
    .slider-context { font-size: 10px; color: var(--muted); margin-top: 2px; font-style: italic; }
    /* Responsive layouts */
    /* Large screens */
    @media (min-width: 1800px) {
      .main-content { max-width: 1800px; margin: 0 auto; }
      .charts { grid-template-columns: repeat(4, 1fr); }
    }
    @media (min-width: 1400px) and (max-width: 1799px) {
      .charts { grid-template-columns: repeat(3, 1fr); }
    }
    @media (min-width: 900px) and (max-width: 1399px) {
      .charts { grid-template-columns: repeat(2, 1fr); }
    }
    @media (max-width: 899px) {
      .charts { grid-template-columns: 1fr; }
    }
    @media (max-width: 800px) {
      .app { grid-template-columns: 1fr; }
      .sidebar {
        position: relative;
        height: auto;
        max-height: 40vh;
        overflow-y: auto;
        border-right: none;
        border-bottom: 1px solid var(--border);
      }
      .main { min-width: 0; overflow-x: hidden; }
      .main-content { padding: 10px; overflow-x: auto; }
      .kpis { grid-template-columns: repeat(auto-fit, minmax(90px, 1fr)); gap: 8px; }
      .tabs { flex-wrap: wrap; gap: 2px; }
      .tab { padding: 6px 10px; font-size: 10px; }
      .header-badges { display: none; }
      .chart-card { padding: 10px; }
      .chart-box { height: 220px; }
      .chart-card.tall .chart-box { height: 220px; }
    }
    @media (max-width: 600px) {
      body { font-size: 12px; }
      .sidebar-content { padding: 8px; }
      .section { padding: 10px; margin-bottom: 8px; }
      .slider-row { margin-bottom: 8px; }
      .kpis { grid-template-columns: repeat(2, 1fr); }
      .kpi { padding: 8px; }
      .kpi-value { font-size: 14px; }
      .chart-card { padding: 8px; }
      .chart-box { height: 200px; }
      .chart-card.tall .chart-box { height: 200px; }
      .legend { gap: 8px; }
      .legend-item { font-size: 9px; }
      .tab { padding: 6px 10px; font-size: 10px; }
      .main-header { padding: 8px 12px; }
    }
    /* LCOC Hero Header */
    .lcoc-hero {
      background: linear-gradient(135deg, var(--orbital) 0%, #004d99 100%);
      color: white;
      padding: 16px 24px;
      border-bottom: 1px solid rgba(0,0,0,0.1);
    }
    .lcoc-hero-inner {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 24px;
      flex-wrap: wrap;
    }
    .lcoc-main { }
    .lcoc-label { font-size: 11px; text-transform: uppercase; letter-spacing: 0.05em; opacity: 0.85; }
    .lcoc-value { font-size: 42px; font-weight: 700; letter-spacing: -0.02em; line-height: 1.1; }
    .lcoc-stats { display: flex; gap: 24px; }
    .lcoc-stat { display: flex; flex-direction: column; padding: 8px 16px; background: rgba(255,255,255,0.1); border-radius: 6px; }
    .lcoc-stat-label { font-size: 10px; text-transform: uppercase; letter-spacing: 0.03em; opacity: 0.8; }
    .lcoc-stat-value { font-size: 18px; font-weight: 600; font-variant-numeric: tabular-nums; }
    .lcoc-advantage { color: #7dffb3; }
    .lcoc-whitepaper-link { 
      font-size: 12px; 
      font-weight: 500; 
      color: white; 
      text-decoration: none; 
      padding: 10px 18px; 
      background: rgba(255,255,255,0.15); 
      border-radius: 6px;
      transition: background 0.2s;
    }
    .lcoc-whitepaper-link:hover { background: rgba(255,255,255,0.25); }
    .back-link {
      font-size: 12px;
      font-weight: 500;
      color: rgba(255,255,255,0.9);
      text-decoration: none;
      padding: 8px 14px;
      background: rgba(255,255,255,0.1);
      border-radius: 6px;
      transition: background 0.2s;
    }
    .back-link:hover { background: rgba(255,255,255,0.2); }
    @media (max-width: 800px) {
      .lcoc-hero { padding: 12px 16px; }
      .lcoc-value { font-size: 32px; }
      .lcoc-stats { gap: 12px; }
      .lcoc-stat { padding: 6px 12px; }
      .lcoc-whitepaper-link { font-size: 11px; padding: 6px 10px; }
    }
  </style>
</head>
<body>
<div class="lcoc-hero">
  <div class="lcoc-hero-inner">
    <a href="/" class="back-link">← Main Simulator</a>
    <div class="lcoc-main">
      <div class="lcoc-label">Baseline LCOC Crossover</div>
      <div class="lcoc-value" id="hero-crossover">2031</div>
    </div>
    <div class="lcoc-stats">
      <div class="lcoc-stat">
        <span class="lcoc-stat-label">Orbital 2035</span>
        <span class="lcoc-stat-value" id="hero-orb35">$0.42</span>
      </div>
      <div class="lcoc-stat">
        <span class="lcoc-stat-label">Ground 2035</span>
        <span class="lcoc-stat-value" id="hero-gnd35">$0.58</span>
      </div>
    </div>
    <a href="/finance/whitepaper.html" class="lcoc-whitepaper-link">Read Whitepaper →</a>
  </div>
</div>
<div class="app">
  <div class="sidebar">
    <div class="sidebar-header">
      <div class="sidebar-title">Orbital Compute </div>
      <div class="sidebar-subtitle">Physics-Based Analysis</div>
    </div>
    <div class="sidebar-content">
      
      <div class="section">
        <div class="section-title">Breakthroughs</div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Thermal Breakthrough</span><span class="slider-val"><span id="v-thermalYear">2030</span></span></div>
          <input type="range" id="thermalYear" min="2026" max="2040" value="2030">
          <div class="toggle-effect" id="eff-thermal">50× lighter heat rejection, MW-class platforms</div>
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Starship</span><span class="slider-val"><span id="v-starshipYear">2029</span></span></div>
          <input type="range" id="starshipYear" min="2026" max="2040" value="2029">
          <div class="toggle-effect" id="eff-starship">5-10× larger satellites, $200→$10/kg launch</div>
        </div>
        <div class="toggle-row">
          <div>
            <div class="toggle-lbl">Space Fission</div>
            <div class="toggle-effect" id="eff-fission">10-100× orbital power only</div>
          </div>
          <div class="toggle-group">
            <input type="number" class="year-input" id="year-fission" value="2035" min="2028" max="2050">
            <label class="toggle"><input type="checkbox" id="tog-fission" checked><span class="toggle-track"></span></label>
          </div>
        </div>
        <div class="toggle-row">
          <div>
            <div class="toggle-lbl">Ground SMR Buildout</div>
            <div class="toggle-effect" id="eff-smr">Ground supply +10-25 GW/yr</div>
          </div>
          <div class="toggle-group">
            <input type="number" class="year-input" id="year-smr" value="2032" min="2028" max="2050">
            <label class="toggle"><input type="checkbox" id="tog-smr" checked><span class="toggle-track"></span></label>
          </div>
        </div>
        <div class="toggle-row">
          <div>
            <div class="toggle-lbl">Fusion Power</div>
            <div class="toggle-effect" id="eff-fusion">GW stations, 100× ground</div>
          </div>
          <div class="toggle-group">
            <input type="number" class="year-input" id="year-fusion" value="2045" min="2035" max="2050">
            <label class="toggle"><input type="checkbox" id="tog-fusion"><span class="toggle-track"></span></label>
          </div>
        </div>
        <div class="toggle-row">
          <div>
            <div class="toggle-lbl">Thermodynamic Computing</div>
            <div class="toggle-effect" id="eff-thermo">TSUs via thermal noise. <a href="https://extropic.ai" target="_blank" style="color: var(--accent);">extropic.ai</a></div>
          </div>
          <div class="toggle-group">
            <input type="number" class="year-input" id="year-thermo" value="2029" min="2027" max="2035">
            <label class="toggle"><input type="checkbox" id="tog-thermo"><span class="toggle-track"></span></label>
          </div>
        </div>
        <div id="thermo-sliders" style="display: none;">
          <div class="slider-row">
            <div class="slider-header"><span class="slider-lbl">Ground Mult</span><span class="slider-val"><span id="v-thermoGroundMult">100</span><span class="unit">×</span></span></div>
            <input type="range" id="thermoGroundMult" min="1" max="3" step="0.1" value="2">
            <div class="toggle-effect">Room-temp silicon TSUs. Limited by thermal noise floor.</div>
          </div>
          <div class="slider-row">
            <div class="slider-header"><span class="slider-lbl">Space Mult</span><span class="slider-val"><span id="v-thermoSpaceMult">1000</span><span class="unit">×</span></span></div>
            <input type="range" id="thermoSpaceMult" min="2" max="4" step="0.1" value="3">
            <div class="toggle-effect">Superconducting TSUs (Josephson junctions). Passive cryo cooling to ~20K.</div>
          </div>
        </div>
        <div class="toggle-row">
          <div>
            <div class="toggle-lbl">Photonic Computing</div>
            <div class="toggle-effect" id="eff-photonic">Light-based matrix ops for deterministic workloads</div>
          </div>
          <div class="toggle-group">
            <input type="number" class="year-input" id="year-photonic" value="2035" min="2026" max="2045">
            <label class="toggle"><input type="checkbox" id="tog-photonic"><span class="toggle-track"></span></label>
          </div>
        </div>
        <div id="photonic-sliders" style="display: none;">
          <div class="slider-row">
            <div class="slider-header"><span class="slider-lbl">Ground Mult</span><span class="slider-val"><span id="v-photonicGroundMult">30</span><span class="unit">×</span></span></div>
            <input type="range" id="photonicGroundMult" min="1" max="3" step="0.1" value="1.48">
            <div class="toggle-effect">Optical matrix multiply. Room temperature.</div>
          </div>
          <div class="slider-row">
            <div class="slider-header"><span class="slider-lbl">Space Mult</span><span class="slider-val"><span id="v-photonicSpaceMult">150</span><span class="unit">×</span></span></div>
            <input type="range" id="photonicSpaceMult" min="1" max="4" step="0.1" value="2.18">
            <div class="toggle-effect">Vacuum optics = no atmospheric scatter.</div>
          </div>
          <div class="slider-row">
            <div class="slider-header"><span class="slider-lbl">Prob. Workload</span><span class="slider-val"><span id="v-workloadProbabilistic">15</span><span class="unit">%</span></span></div>
            <input type="range" id="workloadProbabilistic" min="5" max="50" value="15">
            <div class="toggle-effect">Fraction needing thermodynamic (sampling-heavy).</div>
          </div>
        </div>
      </div>

      <div class="section">
        <div class="section-title">Thermal</div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Emissivity</span><span class="slider-val"><span id="v-emissivity">0.85</span></span></div>
          <input type="range" id="emissivity" min="70" max="95" value="85">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Op Temp</span><span class="slider-val"><span id="v-opTemp">365</span><span class="unit">K</span></span></div>
          <input type="range" id="opTemp" min="300" max="400" value="365">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Rad Learn</span><span class="slider-val"><span id="v-radLearn">50</span><span class="unit">kg/MW/yr</span></span></div>
          <input type="range" id="radLearn" min="0" max="100" value="50">
        </div>
      </div>
      
      <div class="section">
        <div class="section-title">Power</div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Solar Eff</span><span class="slider-val"><span id="v-solarEff">20</span><span class="unit">%</span></span></div>
          <input type="range" id="solarEff" min="15" max="50" value="20">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Solar Learn</span><span class="slider-val"><span id="v-solarLearn">0.8</span><span class="unit">%/yr</span></span></div>
          <input type="range" id="solarLearn" min="0" max="20" value="8">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Base Power</span><span class="slider-val"><span id="v-basePower">300</span><span class="unit">kW</span></span></div>
          <input type="range" id="basePower" min="100" max="800" value="300">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Compute %</span><span class="slider-val"><span id="v-computeFrac">68</span><span class="unit">%</span></span></div>
          <input type="range" id="computeFrac" min="50" max="80" value="68">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Battery Dens</span><span class="slider-val"><span id="v-battDens">280</span><span class="unit">Wh/kg</span></span></div>
          <input type="range" id="battDens" min="200" max="500" value="280">
        </div>
      </div>
      
      <div class="section">
        <div class="section-title">Compute</div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Rad Penalty</span><span class="slider-val"><span id="v-radPen">30</span><span class="unit">%</span></span></div>
          <input type="range" id="radPen" min="10" max="60" value="30">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">AI Learn Rate</span><span class="slider-val"><span id="v-aiLearn">20</span><span class="unit">%/yr</span></span></div>
          <input type="range" id="aiLearn" min="5" max="35" value="20">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Sat Lifetime</span><span class="slider-val"><span id="v-satLife">10</span><span class="unit">yrs</span></span></div>
          <input type="range" id="satLife" min="3" max="15" value="10">
        </div>
      </div>
      
      <div class="section">
        <div class="section-title">Economics</div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Launch $/kg</span><span class="slider-val">$<span id="v-launchCost">1500</span></span></div>
          <input type="range" id="launchCost" min="200" max="2500" value="1500">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Launch Learn</span><span class="slider-val"><span id="v-launchLearn">18</span><span class="unit">%</span></span></div>
          <input type="range" id="launchLearn" min="10" max="50" value="18">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Floor $/kg</span><span class="slider-val">$<span id="v-launchFloor">10</span></span></div>
          <input type="range" id="launchFloor" min="5" max="200" value="10">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Prod Mult</span><span class="slider-val"><span id="v-prodMult">2.5</span><span class="unit">×</span></span></div>
          <input type="range" id="prodMult" min="5" max="50" value="25">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Mfg Cost Mult</span><span class="slider-val"><span id="v-mfgCostMult">1.0</span><span class="unit">×</span></span></div>
          <input type="range" id="mfgCostMult" min="5" max="30" value="10">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Maint Cost</span><span class="slider-val"><span id="v-maintCost">1.5</span><span class="unit">%/yr</span></span></div>
          <input type="range" id="maintCost" min="1" max="30" step="0.5" value="1.5">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">WACC Orbital</span><span class="slider-val"><span id="v-waccOrbital">10</span><span class="unit">%</span></span></div>
          <input type="range" id="waccOrbital" min="5" max="25" value="10">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">WACC Ground</span><span class="slider-val ground"><span id="v-waccGround">8</span><span class="unit">%</span></span></div>
          <input type="range" class="ground" id="waccGround" min="3" max="15" value="8">
        </div>
      </div>
      
      <div class="section">
        <div class="section-title">Infrastructure</div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Base BW</span><span class="slider-val"><span id="v-bandwidth">20</span><span class="unit">Tbps</span></span></div>
          <input type="range" id="bandwidth" min="5" max="100" value="20">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">BW Growth</span><span class="slider-val"><span id="v-bwGrowth">25</span><span class="unit">%/yr</span></span></div>
          <input type="range" id="bwGrowth" min="10" max="40" value="25">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">BW $/Gbps</span><span class="slider-val">$<span id="v-bwCost">50</span><span class="unit">k</span></span></div>
          <input type="range" id="bwCost" min="10" max="200" value="50">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">BW/TFLOP</span><span class="slider-val"><span id="v-gbpsPerTflop">0.5</span><span class="unit">kbps</span></span></div>
          <input type="range" id="gbpsPerTflop" min="0.1" max="10" step="0.1" value="0.5">
        </div>
      </div>
      
      <div class="section">
        <div class="section-title ground">Ground DC</div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Ground PUE</span><span class="slider-val ground"><span id="v-groundPue">1.30</span></span></div>
          <input type="range" class="ground" id="groundPue" min="105" max="180" value="130">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Energy $/kWh</span><span class="slider-val ground">$<span id="v-energyCost">0.065</span></span></div>
          <input type="range" class="ground" id="energyCost" min="30" max="150" value="65">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Energy Escal</span><span class="slider-val ground"><span id="v-energyEscal">4</span><span class="unit">%/yr</span></span></div>
          <input type="range" class="ground" id="energyEscal" min="0" max="10" value="4">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Build Delay</span><span class="slider-val ground"><span id="v-interconnect">48</span><span class="unit">mo</span></span></div>
          <input type="range" class="ground" id="interconnect" min="6" max="60" value="48">
        </div>
      </div>
      
      <div class="section">
        <div class="section-title ground">Market</div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">2026 Demand</span><span class="slider-val ground"><span id="v-demand2025">195</span><span class="unit">Exaflops</span></span></div>
          <input type="range" class="ground" id="demand2025" min="90" max="450" value="195">
          <div class="slider-context" id="demand-context">(≈ 307 Petatok/yr | ≈ 65 GW @ baseline)</div>
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Demand Growth</span><span class="slider-val ground"><span id="v-demandGrowth">55</span><span class="unit">%/yr</span></span></div>
          <input type="range" class="ground" id="demandGrowth" min="20" max="80" value="55">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Batch Eligible</span><span class="slider-val"><span id="v-orbitalEligibleShare">35</span><span class="unit">%</span></span></div>
          <input type="range" id="orbitalEligibleShare" min="10" max="80" value="35">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">2026 Supply</span><span class="slider-val ground"><span id="v-supply2025">60</span><span class="unit">GW</span></span></div>
          <input type="range" class="ground" id="supply2025" min="30" max="150" value="60">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">Supply Growth</span><span class="slider-val ground"><span id="v-supplyGrowth">8</span><span class="unit">%/yr</span></span></div>
          <input type="range" class="ground" id="supplyGrowth" min="5" max="25" value="8">
        </div>
      </div>

      <div class="section">
        <div class="section-title ground">Behind-the-Meter</div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">BTM Share</span><span class="slider-val ground"><span id="v-btmShare">15</span><span class="unit">%</span></span></div>
          <input type="range" class="ground" id="btmShare" min="0" max="40" value="15">
          <div class="toggle-effect">On-site solar+storage bypassing grid queues</div>
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">BTM Deploy</span><span class="slider-val ground"><span id="v-btmDelay">12</span><span class="unit">mo</span></span></div>
          <input type="range" class="ground" id="btmDelay" min="6" max="24" value="12">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">BTM Capex</span><span class="slider-val ground"><span id="v-btmCapexMult">1.35</span><span class="unit">×</span></span></div>
          <input type="range" class="ground" id="btmCapexMult" min="100" max="200" value="135">
        </div>
        <div class="slider-row">
          <div class="slider-header"><span class="slider-lbl">BTM Energy</span><span class="slider-val ground">$<span id="v-btmEnergyCost">0.040</span><span class="unit">/kWh</span></span></div>
          <input type="range" class="ground" id="btmEnergyCost" min="20" max="80" value="40">
          <div class="toggle-effect">Solar+storage LCOS (Lazard data)</div>
        </div>
      </div>

      <details class="derived-section">
        <summary class="section-title">Derived Values</summary>
        <div class="derived-grid">
          <div class="derived-item">
            <span class="derived-label">Rad Power</span>
            <span class="derived-value" id="d-radPower">--</span>
            <span class="derived-unit">W/m²</span>
          </div>
          <div class="derived-item">
            <span class="derived-label">Rad Mass</span>
            <span class="derived-value" id="d-radMass">--</span>
            <span class="derived-unit">kg/MW</span>
          </div>
          <div class="derived-item">
            <span class="derived-label">Launch LEO</span>
            <span class="derived-value" id="d-launchLeo">--</span>
            <span class="derived-unit">$/kg</span>
          </div>
          <div class="derived-item">
            <span class="derived-label">Launch GEO</span>
            <span class="derived-value" id="d-launchGeo">--</span>
            <span class="derived-unit">$/kg</span>
          </div>
          <div class="derived-item">
            <span class="derived-label">Sat Power</span>
            <span class="derived-value" id="d-satPower">--</span>
            <span class="derived-unit">kW</span>
          </div>
          <div class="derived-item">
            <span class="derived-label">Sat Mass</span>
            <span class="derived-value" id="d-satMass">--</span>
            <span class="derived-unit">kg</span>
          </div>
          <div class="derived-item">
            <span class="derived-label">Demand '35</span>
            <span class="derived-value" id="d-demand35">--</span>
            <span class="derived-unit">GW</span>
          </div>
          <div class="derived-item">
            <span class="derived-label">Supply '35</span>
            <span class="derived-value" id="d-supply35">--</span>
            <span class="derived-unit">GW</span>
          </div>
        </div>
      </details>
      
    </div>
  </div>
  
  <div class="main">
    <div class="main-header">
      <div class="tabs">
        <button class="tab active" data-tab="core">Core</button>
        <button class="tab" data-tab="market">Market</button>
        <button class="tab" data-tab="constraints">Constraints</button>
        <button class="tab" data-tab="physics">Physics</button>
        <button class="tab" data-tab="futures">Futures</button>
      </div>
      <div class="header-badges">
        <div class="badge-item">
          <span class="badge-label">Crossover</span>
          <span class="badge-value orbital" id="badge-crossover">--</span>
        </div>
        <div class="badge-item">
          <span class="badge-label">Fleet 2050</span>
          <span class="badge-value warning" id="badge-fleet50">--</span>
        </div>
      </div>
    </div>
    
    <div class="main-content">
      <!-- CORE TAB -->
      <div class="tab-panel active" data-tab="core">
        <div class="kpis">
          <div class="kpi orbital"><div class="kpi-label">Orb 2035</div><div class="kpi-value" id="kpi-orb35">--</div></div>
          <div class="kpi ground"><div class="kpi-label">Gnd 2035</div><div class="kpi-value" id="kpi-gnd35">--</div></div>
          <div class="kpi orbital"><div class="kpi-label">Orb 2050</div><div class="kpi-value" id="kpi-orb50">--</div></div>
          <div class="kpi ground"><div class="kpi-label">Gnd 2050</div><div class="kpi-value" id="kpi-gnd50">--</div></div>
          <div class="kpi warning"><div class="kpi-label">Delivered 2035</div><div class="kpi-value" id="kpi-tokens35">--</div></div>
          <div class="kpi accent"><div class="kpi-label">Delivered 2050</div><div class="kpi-value" id="kpi-tokens50">--</div></div>
        </div>
        <div class="charts">
          <div class="chart-card wide tall">
            <div class="chart-header">
              <div class="chart-title">LCOC with Uncertainty ($/GPU-hr)</div>
              <div class="chart-desc">Orbital vs Ground market price. Bands = scenario range.</div>
              <div class="sla-note">SLA: 99.9% uptime (8.76 hrs/yr downtime)</div>
            </div>
            <div class="chart-box"><canvas id="c-lcoc"></canvas></div>
            <div class="legend">
              <div class="legend-item"><div class="legend-dot" style="background:var(--orbital)"></div>Orbital (baseline)</div>
              <div class="legend-item"><div class="legend-dot" style="background:rgba(0,102,204,0.3)"></div>Orbital range</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--ground)"></div>Ground (LCOC)</div>
            </div>
          </div>
          <div class="chart-card">
            <div class="chart-header">
              <div class="chart-title">Orbital Fleet (TW)</div>
              <div class="chart-desc">All shells: LEO, MEO, GEO, Cislunar</div>
            </div>
            <div class="chart-box"><canvas id="c-fleet"></canvas></div>
            <div class="legend">
              <div class="legend-item"><div class="legend-dot" style="background:var(--orbital)"></div>LEO</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--accent)"></div>MEO</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--warning)"></div>GEO</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--purple)"></div>Cislunar</div>
            </div>
          </div>
          <div class="chart-card">
            <div class="chart-header">
              <div class="chart-title">Carbon (gCO₂/TFLOP-hr)</div>
              <div class="chart-desc">Orbital = embodied; Ground = grid + embodied</div>
            </div>
            <div class="chart-box"><canvas id="c-carbon"></canvas></div>
            <div class="legend">
              <div class="legend-item"><div class="legend-dot" style="background:var(--orbital)"></div>Orbital</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--ground)"></div>Ground</div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- MARKET TAB -->
      <div class="tab-panel" data-tab="market">
        <div class="kpis">
          <div class="kpi warning"><div class="kpi-label">Peak Premium</div><div class="kpi-value" id="kpi-peakPrem">--</div></div>
          <div class="kpi ground"><div class="kpi-label">Premium 2035</div><div class="kpi-value" id="kpi-prem35">--</div></div>
          <div class="kpi accent"><div class="kpi-label">Unmet 2035</div><div class="kpi-value" id="kpi-unmet35">--</div></div>
        </div>
        <div class="charts">
          <div class="chart-card wide tall">
            <div class="chart-header">
              <div class="chart-title">Supply vs Demand (GW)</div>
              <div class="chart-desc">Gap drives scarcity premium. Orbital-eligible demand = total × eligible share.</div>
            </div>
            <div class="chart-box"><canvas id="c-supplyDemand"></canvas></div>
            <div class="legend">
              <div class="legend-item"><div class="legend-dot" style="background:var(--ground)"></div>Total Demand</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--muted)"></div>Ground Supply</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--orbital)"></div>Total Supply</div>
            </div>
          </div>
          <div class="chart-card wide">
            <div class="chart-header">
              <div class="chart-title">Scarcity Premium (×)</div>
              <div class="chart-desc">Price multiplier from unmet demand</div>
            </div>
            <div class="chart-box"><canvas id="c-scarcity"></canvas></div>
          </div>
        </div>
      </div>
      
      <!-- CONSTRAINTS TAB -->
      <div class="tab-panel" data-tab="constraints">
        <div class="kpis">
          <div class="kpi accent"><div class="kpi-label">BW Util 2035</div><div class="kpi-value" id="kpi-bwUtil">--</div></div>
          <div class="kpi orbital"><div class="kpi-label">Platforms 2035</div><div class="kpi-value" id="kpi-plat35">--</div></div>
          <div class="kpi purple"><div class="kpi-label">Platforms 2050</div><div class="kpi-value" id="kpi-plat50">--</div></div>
        </div>
        <div class="charts">
          <div class="chart-card wide">
            <div class="chart-header">
              <div class="chart-title">Shell Utilization (%)</div>
              <div class="chart-desc">LEO: 300k, MEO: 50k, GEO: 1.8k, Cislunar: 700k capacity</div>
            </div>
            <div class="chart-box"><canvas id="c-shellUtil"></canvas></div>
            <div class="legend">
              <div class="legend-item"><div class="legend-dot" style="background:var(--orbital)"></div>LEO</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--accent)"></div>MEO</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--warning)"></div>GEO</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--purple)"></div>Cislunar</div>
            </div>
          </div>
          <div class="chart-card">
            <div class="chart-header">
              <div class="chart-title">Bandwidth Utilization (%)</div>
              <div class="chart-desc">Available / needed. Low = stranded capacity.</div>
            </div>
            <div class="chart-box"><canvas id="c-bwUtil"></canvas></div>
          </div>
          <div class="chart-card">
            <div class="chart-header">
              <div class="chart-title">Bandwidth Capacity (Tbps)</div>
              <div class="chart-desc">Ground segment optical links</div>
            </div>
            <div class="chart-box"><canvas id="c-bandwidth"></canvas></div>
          </div>
          <div class="chart-card">
            <div class="chart-header">
              <div class="chart-title">Stranded Capex Penalty (×)</div>
              <div class="chart-desc">LCOC multiplier from underutilization</div>
            </div>
            <div class="chart-box"><canvas id="c-stranded"></canvas></div>
          </div>
          <div class="chart-card">
            <div class="chart-header">
              <div class="chart-title">Radiator Mass (kg/kW)</div>
              <div class="chart-desc">Thermal breakthrough: 50× lighter heat rejection</div>
            </div>
            <div class="chart-box"><canvas id="c-thermal"></canvas></div>
          </div>
          <div class="chart-card">
            <div class="chart-header">
              <div class="chart-title">Bottleneck Analysis</div>
              <div class="chart-desc">Dominant constraint each period</div>
            </div>
            <div class="chart-box"><canvas id="c-bottleneck"></canvas></div>
            <div class="legend">
              <div class="legend-item"><div class="legend-dot" style="background:rgba(204,102,0,0.9)"></div>Thermal</div>
              <div class="legend-item"><div class="legend-dot" style="background:rgba(204,170,0,0.9)"></div>Power</div>
              <div class="legend-item"><div class="legend-dot" style="background:rgba(0,102,204,0.9)"></div>Bandwidth</div>
              <div class="legend-item"><div class="legend-dot" style="background:rgba(102,51,204,0.9)"></div>Orbital Slots</div>
              <div class="legend-item"><div class="legend-dot" style="background:rgba(0,153,102,0.9)"></div>Demand</div>
              <div class="legend-item"><div class="legend-dot" style="background:rgba(153,51,51,0.9)"></div>Launch Cap</div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- PHYSICS TAB -->
      <div class="tab-panel" data-tab="physics">
        <div class="kpis">
          <div class="kpi orbital"><div class="kpi-label">LEO Power</div><div class="kpi-value" id="kpi-leo">--</div></div>
          <div class="kpi purple"><div class="kpi-label">Cislunar</div><div class="kpi-value" id="kpi-cis">--</div></div>
          <div class="kpi accent"><div class="kpi-label">Mass 2035</div><div class="kpi-value" id="kpi-mass">--</div></div>
        </div>
        <div class="charts">
          <div class="chart-card">
            <div class="chart-header">
              <div class="chart-title">Mass Breakdown (kg)</div>
              <div class="chart-desc">Advanced thermal: 50× lighter</div>
            </div>
            <div class="chart-box"><canvas id="c-mass"></canvas></div>
            <div class="legend">
              <div class="legend-item"><div class="legend-dot" style="background:var(--warning)"></div>Solar/Reactor</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--purple)"></div>Battery</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--orbital)"></div>Compute</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--ground)"></div>Radiator</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--muted)"></div>Structure</div>
            </div>
          </div>
          <div class="chart-card">
            <div class="chart-header">
              <div class="chart-title">Launch Cost ($/kg)</div>
              <div class="chart-desc">Learning curve to $10/kg floor</div>
            </div>
            <div class="chart-box"><canvas id="c-launch"></canvas></div>
          </div>
          <div class="chart-card">
            <div class="chart-header">
              <div class="chart-title">Compute Efficiency (GFLOPS/W)</div>
              <div class="chart-desc">AI learning rate drives improvement</div>
            </div>
            <div class="chart-box"><canvas id="c-efficiency"></canvas></div>
            <div class="legend">
              <div class="legend-item"><div class="legend-dot" style="background:var(--orbital)"></div>Orbital</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--ground)"></div>Ground</div>
            </div>
          </div>
          <div class="chart-card wide">
            <div class="chart-header">
              <div class="chart-title">Platform Power by Shell (MW)</div>
              <div class="chart-desc">Fission/fusion enable 10-1000× power jump</div>
            </div>
            <div class="chart-box"><canvas id="c-power"></canvas></div>
            <div class="legend">
              <div class="legend-item"><div class="legend-dot" style="background:var(--orbital)"></div>LEO</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--accent)"></div>MEO</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--warning)"></div>GEO</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--purple)"></div>Cislunar</div>
            </div>
          </div>
          <div class="chart-card">
            <div class="chart-header">
              <div class="chart-title">Specific Power (W/kg)</div>
              <div class="chart-desc">Key figure of merit for orbital</div>
            </div>
            <div class="chart-box"><canvas id="c-specPower"></canvas></div>
          </div>
          <div class="chart-card">
            <div class="chart-header">
              <div class="chart-title">Power Budget (%)</div>
              <div class="chart-desc">Compute vs thermal vs housekeeping</div>
            </div>
            <div class="chart-box"><canvas id="c-powerBudget"></canvas></div>
            <div class="legend">
              <div class="legend-item"><div class="legend-dot" style="background:var(--orbital)"></div>Compute</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--orange)"></div>Thermal</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--muted)"></div>Housekeeping</div>
            </div>
          </div>
          <div class="chart-card">
            <div class="chart-header">
              <div class="chart-title">Data Rate per Platform (Gbps)</div>
              <div class="chart-desc">Link budget based on compute output</div>
            </div>
            <div class="chart-box"><canvas id="c-dataRate"></canvas></div>
          </div>
          <div class="chart-card">
            <div class="chart-header">
              <div class="chart-title">Radiation: Reliability Overhead (%)</div>
              <div class="chart-desc">SEU-driven redundancy by shell (improves with rad-hard tech)</div>
            </div>
            <div class="chart-box"><canvas id="c-reliability"></canvas></div>
            <div class="legend">
              <div class="legend-item"><div class="legend-dot" style="background:var(--orbital)"></div>LEO</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--warning)"></div>MEO</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--accent)"></div>GEO</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--purple)"></div>Cislunar</div>
            </div>
          </div>
          <div class="chart-card">
            <div class="chart-header">
              <div class="chart-title">EROL (Energy Return on Launch)</div>
              <div class="chart-desc">Lifetime energy output vs launch energy</div>
            </div>
            <div class="chart-box"><canvas id="c-erol"></canvas></div>
          </div>
          <div class="chart-card">
            <div class="chart-header">
              <div class="chart-title">Power per TFLOP (kW/TFLOP)</div>
              <div class="chart-desc">Efficiency gains reduce power needs. Thermo/photonic show dramatic drops.</div>
            </div>
            <div class="chart-box"><canvas id="c-powerPerTflop"></canvas></div>
            <div class="legend">
              <div class="legend-item"><div class="legend-dot" style="background:var(--orbital)"></div>Orbital</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--ground)"></div>Ground</div>
            </div>
          </div>
                  </div>
      </div>

      <!-- FUTURES TAB -->
      <div class="tab-panel" data-tab="futures">
        <div class="kpis">
          <div class="kpi orbital"><div class="kpi-label">Aggressive</div><div class="kpi-value" id="kpi-crossAgg">--</div></div>
          <div class="kpi accent"><div class="kpi-label">Baseline</div><div class="kpi-value" id="kpi-crossBase">--</div></div>
          <div class="kpi ground"><div class="kpi-label">Conservative</div><div class="kpi-value" id="kpi-crossCons">--</div></div>
        </div>

        <!-- Feedback Loops & Lunar Readiness -->
        <div class="feedback-panels" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; padding: 16px;">
          <!-- Fleet & Starship Panel -->
          <div class="feedback-panel" style="background: var(--surface); border-radius: 12px; padding: 16px; border: 1px solid var(--border);">
            <div class="panel-title" style="font-weight: 600; color: var(--orbital); margin-bottom: 12px; font-size: 14px;">Fleet (2040)</div>
            <div class="panel-row" style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--border); font-size: 13px;"><span>LEO Platforms</span><span id="kpi-leoCapacity40" style="font-weight: 500;">--</span></div>
            <div class="panel-row" style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--border); font-size: 13px;"><span>Total Fleet Mass</span><span id="kpi-fleetMass40" style="font-weight: 500;">--</span></div>
            <div class="panel-row" style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--border); font-size: 13px;"><span>Starship Flights to Deploy</span><span id="kpi-starshipFlights40" style="font-weight: 500;">--</span></div>
            <div class="panel-row" style="display: flex; justify-content: space-between; padding: 6px 0; font-size: 13px;"><span>Annual Flights</span><span id="kpi-annualFlights40" style="font-weight: 500;">--</span></div>
          </div>

          <!-- AI Acceleration Panel -->
          <div class="feedback-panel" style="background: var(--surface); border-radius: 12px; padding: 16px; border: 1px solid var(--border);">
            <div class="panel-title" style="font-weight: 600; color: var(--accent); margin-bottom: 12px; font-size: 14px;">AI Acceleration (2040)</div>
            <div class="panel-row" style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--border); font-size: 13px;"><span>Global Compute</span><span id="kpi-globalCompute40" style="font-weight: 500;">--</span></div>
            <div class="panel-row" style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--border); font-size: 13px;"><span>R&D Stock (K)</span><span id="kpi-rndStock40" style="font-weight: 500;">--</span></div>
            <div class="panel-row" style="display: flex; justify-content: space-between; padding: 6px 0; font-size: 13px;"><span>Launch Learn Boost</span><span id="kpi-launchLearnBoost" style="font-weight: 500;">--</span></div>
          </div>

          <!-- Lunar Readiness Panel -->
          <div class="feedback-panel" style="background: var(--surface); border-radius: 12px; padding: 16px; border: 1px solid var(--border);">
            <div class="panel-title" style="font-weight: 600; color: var(--ground); margin-bottom: 12px; font-size: 14px;">Lunar Infrastructure</div>
            <div class="panel-row" style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--border); font-size: 13px;"><span>Readiness (2040)</span><span id="kpi-lunarReadiness" style="font-weight: 500;">--</span></div>
            <div class="panel-row" style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--border); font-size: 13px;"><span>Unlock Year</span><span id="kpi-lunarUnlock" style="font-weight: 500;">--</span></div>
            <div class="panel-status" id="kpi-lunarStatus" style="margin-top: 8px; padding: 8px; background: rgba(0,0,0,0.05); border-radius: 6px; font-size: 12px; color: var(--muted); text-align: center;">--</div>
          </div>
        </div>

        <div class="charts">
          <div class="chart-card wide tall">
            <div class="chart-header">
              <div class="chart-title">LCOC Scenarios ($/GPU-hr)</div>
              <div class="chart-desc">Deployment ramp timing under different assumptions</div>
            </div>
            <div class="chart-box"><canvas id="c-lcocScenarios"></canvas></div>
            <div class="legend">
              <div class="legend-item"><div class="legend-dot" style="background:var(--orbital)"></div>Orbital (baseline)</div>
              <div class="legend-item"><div class="legend-dot" style="background:rgba(0,102,204,0.3)"></div>Orbital range</div>
              <div class="legend-item"><div class="legend-dot" style="background:var(--muted)"></div>Ground (LCOC)</div>
            </div>
          </div>
          <div class="chart-card wide">
            <div class="chart-header">
              <div class="chart-title">Carbon Scenarios (gCO₂/TFLOP-hr)</div>
              <div class="chart-desc">Emissions trajectory under each scenario</div>
            </div>
            <div class="chart-box"><canvas id="c-carbonScenarios"></canvas></div>
            <div class="legend">
              <div class="legend-item"><div class="legend-dot" style="background:var(--orbital)"></div>Orbital (baseline)</div>
              <div class="legend-item"><div class="legend-dot" style="background:rgba(0,102,204,0.3)"></div>Orbital range</div>
            </div>
          </div>
          <div class="chart-card wide">
            <div class="chart-header">
              <div class="chart-title">Efficiency Scenarios (GFLOPS/W)</div>
              <div class="chart-desc">Compute efficiency improvement</div>
            </div>
            <div class="chart-box"><canvas id="c-effScenarios"></canvas></div>
            <div class="legend">
              <div class="legend-item"><div class="legend-dot" style="background:var(--orbital)"></div>Orbital (baseline)</div>
              <div class="legend-item"><div class="legend-dot" style="background:rgba(0,102,204,0.3)"></div>Orbital range</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
<script>
// BUNDLED MODEL FROM src/model/*.ts - SAME AS MAIN SIMULATOR
"use strict";
var Model = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // bundle-finance.ts
  var bundle_finance_exports = {};
  __export(bundle_finance_exports, {
    SHELLS: () => SHELLS,
    SLA: () => SLA,
    STEFAN_BOLTZMANN: () => STEFAN_BOLTZMANN,
    YEARS: () => YEARS,
    calcFleet: () => calcFleet,
    calcGround: () => calcGround,
    calcSatellite: () => calcSatellite,
    defaults: () => defaults,
    getBandwidth: () => getBandwidth,
    getBtmShare: () => getBtmShare,
    getDemand: () => getDemand,
    getGroundEfficiency: () => getGroundEfficiency,
    getGroundSupply: () => getGroundSupply,
    getLaunchCost: () => getLaunchCost,
    getOrbitalEfficiency: () => getOrbitalEfficiency,
    getRadiatorMassPerMW: () => getRadiatorMassPerMW,
    getShellRadiationEffects: () => getShellRadiationEffects,
    resetFleetTracker: () => resetFleetTracker
  });

  // src/model/constants.ts
  var STEFAN_BOLTZMANN = 567e-10;
  var YEARS = Array.from({ length: 45 }, (_, i) => 2026 + i);
  var SLA = 0.999;
  var SHELLS = {
    leo: { alt: 550, latency: 3.7, tidMult: 1, seuMult: 1, capacity: 2e6 },
    // Low Earth Orbit - enables 10 TW fleet by 2050
    meo: { alt: 1e4, latency: 67, tidMult: 3, seuMult: 2.5, capacity: 1e5 },
    // Van Allen radiation belt
    geo: { alt: 35786, latency: 120, tidMult: 0.6, seuMult: 0.8, capacity: 1800 },
    // Geostationary orbit (slot-limited)
    cislunar: { alt: 384400, latency: 1300, tidMult: 0.4, seuMult: 1.2, capacity: 1e6 }
    // Earth-Moon space
  };
  var SHELL_COST_MULT = {
    leo: 1,
    meo: 1.3,
    geo: 1.6,
    cislunar: 2.5
  };

  // src/model/market.ts
  function getDemand(year, params) {
    let demand = params.demand2025;
    for (let y = 2026; y <= year; y++) {
      const t = y - 2026;
      const growth = Math.max(0.15, params.demandGrowth + 0.2 - t * 0.02);
      demand *= 1 + growth;
    }
    return demand;
  }
  function getBtmShare(year, params) {
    const t = year - 2026;
    const queuePain = params.interconnect / 36;
    const energyPain = params.energyCost / 0.065;
    const btmIncentive = (queuePain + energyPain) / 2;
    return Math.min(0.5, params.btmShare * btmIncentive + t * params.btmShareGrowth);
  }
  function getGroundSupply(year, params) {
    const t = year - 2026;
    const yearBtmShare = getBtmShare(year, params);

    // Grid supply grows with compound rate BUT is delayed by interconnect queue
    // BTM supply grows faster (shorter delay) but is a fraction of total
    const gridDelay = params.interconnect / 12; // years
    const btmDelay = params.btmDelay / 12;      // years

    // Compound growth model (like demand) but with delays
    // Grid: delayed by interconnect queue, grows at supplyGrowth rate
    // BTM: faster deployment, grows at 1.5x supplyGrowth rate
    let gridSupply = params.supply2025 * (1 - yearBtmShare);
    let btmSupply = params.supply2025 * yearBtmShare;

    for (let y = 2026; y < year; y++) {
      const yearsSinceStart = y - 2026;
      // Grid only grows after interconnect delay
      if (yearsSinceStart >= gridDelay) {
        gridSupply *= (1 + params.supplyGrowth);
      }
      // BTM grows faster after shorter delay
      if (yearsSinceStart >= btmDelay) {
        btmSupply *= (1 + params.supplyGrowth * 1.5);
      }
    }

    let baseSupply = gridSupply + btmSupply;

    // SMR boost (ground nuclear)
    if (params.smrOn && year >= params.smrYear) {
      const smrMaturity = Math.min(1, (year - params.smrYear) / 5);
      const smrBoost = (10 + smrMaturity * 20) * (year - params.smrYear);
      baseSupply += smrBoost;
    }
    return baseSupply;
  }
  function getDemandPressure(year, params) {
    const demand = getDemand(year, params);
    const supply = getGroundSupply(year, params);
    // Allow demand pressure to range from 0.2 (oversupply) to 5.0 (severe scarcity)
    // This is THE CORE THESIS: massive demand growth creates scarcity that makes space viable
    return Math.max(0.2, Math.min(5.0, demand / supply));
  }

  // src/model/physics.ts
  function getLaunchCost(year, params, shell = "leo") {
    const scaleFactor = (params.launchCost || 1500) / 1500;
    const baseLearnRate = params.launchLearn || 0.18;
    const starshipYear = params.starshipOn ? (params.starshipYear || 2029) : 2100; // Never if disabled
    let cost;
    let floor;
    if (year < starshipYear) {
      // Pre-Starship: Falcon 9 era - MUCH slower learning, higher floor
      // Falcon 9 is expendable-derived, limited reuse potential
      const yearsOfLearning = year - 2026;
      cost = 2500 * scaleFactor * Math.pow(1 - baseLearnRate * 0.3, yearsOfLearning);
      floor = 800; // Falcon 9 can't get below ~$800/kg (limited reuse)
    } else {
      // Post-Starship: fully reusable, rapid learning to very low floor
      const yearsOfLearning = year - starshipYear;
      const starshipBase = 400 * scaleFactor; // Starship starts cheaper
      cost = starshipBase * Math.pow(1 - baseLearnRate, yearsOfLearning);
      floor = params.launchFloor; // Can reach $10-15/kg with full reuse
    }
    return Math.max(floor, cost) * (SHELL_COST_MULT[shell] || 1);
  }
  function getRadiatorMassPerMW(year, powerKw, params) {
    // FIRST PRINCIPLES DERIVATION:
    // Stefan-Boltzmann: P = εσT⁴ where σ = 5.67e-8 W/m²K⁴
    // At 350K: P = 0.85 × 5.67e-8 × 350⁴ = 723 W/m²
    // Area per MW = 1,000,000 / 723 = 1,383 m²
    // Conventional heat pipes: 5-10 kg/m² → 6,900-13,800 kg/MW
    // Droplet radiators: 0.3-0.5 kg/m² → 415-690 kg/MW at 350K
    // At 500K: ~100 kg/MW with aggressive droplet radiators
    const tempFactor = Math.pow(350 / params.opTemp, 4);
    const emissivityFactor = 0.85 / params.emissivity;

    if (!params.thermalOn || year < params.thermalYear) {
      // Conventional heat pipe radiators: ~5000-7000 kg/MW
      // Improves slowly with better materials
      const t = year - 2026;
      const baseMass = Math.max(800, 6000 * tempFactor * emissivityFactor - t * params.radLearn);
      const powerPenalty = 1 + (powerKw / 200) * 0.3;
      return baseMass * powerPenalty;
    }

    // Advanced thermal (droplet radiators):
    // Best case: 0.3 kg/m² at 500K → ~100 kg/MW
    // Conservative: 0.5 kg/m² at 400K → ~200 kg/MW
    // Model: 100→50 kg/MW over 8 years of maturity (aggressive but physics-based)
    const maturity = Math.min(1, (year - params.thermalYear) / 8);
    const advancedBase = 100 - maturity * 50; // 100 kg/MW → 50 kg/MW
    return advancedBase * tempFactor * emissivityFactor;
  }
  function getGroundEfficiency(year, params) {
    const H100_BASELINE = 2800;  // GFLOPS/W
    let baseEff = H100_BASELINE;
    for (let y = 2026; y < year; y++) {
      const demandPressure = getDemandPressure(y, params);
      // High demand drives more R&D investment in chip efficiency
      // At normal demand (1.0): 1.0x learning rate
      // At 2x demand: 1.3x learning rate
      // At 5x demand: 2.0x learning rate (massive R&D push)
      const normalizedPressure = (demandPressure - 1) / 4; // 0 at 1.0, 1 at 5.0
      const groundLearningMult = 1.0 + Math.max(0, normalizedPressure);
      const baseLearn = Math.max(0.03, params.aiLearn - (y - 2026) * 0.007);
      baseEff *= 1 + baseLearn * groundLearningMult;
    }
    // No hard cap - let learning continue (matches stable version)
    // Physical limits (Landauer, memory bandwidth) handled by learning rate floor

    const hasThermoCompute = params.thermoOn && year >= params.thermoYear;
    const hasPhotonic = params.photonicOn && year >= params.photonicYear;
    if (hasThermoCompute || hasPhotonic) {
      const deterministicFrac = 1 - params.workloadProbabilistic;
      const probFrac = params.workloadProbabilistic;
      const photonicMult = hasPhotonic ? params.photonicGroundMult : 1;
      const thermoMult = hasThermoCompute ? params.thermoGroundMult : 1;
      return baseEff * (photonicMult * deterministicFrac + thermoMult * probFrac);
    }
    return baseEff;
  }
  function getOrbitalEfficiency(year, params) {
    let baseEff = 2800;
    for (let y = 2026; y < year; y++) {
      const demandPressure = getDemandPressure(y, params);
      // High demand drives more R&D investment in chip efficiency
      // Same logic as ground: 1.0x at normal demand, up to 2.0x at 5x demand
      const normalizedPressure = (demandPressure - 1) / 4; // 0 at 1.0, 1 at 5.0
      const learningMult = 1.0 + Math.max(0, normalizedPressure);
      const baseLearn = Math.max(0.03, params.aiLearn - (y - 2026) * 7e-3);
      baseEff *= 1 + baseLearn * learningMult;
    }
    const penalty = params.radPen * Math.pow(0.82, year - 2026);
    baseEff *= 1 - Math.max(0.02, penalty);
    const hasThermoCompute = params.thermoOn && year >= params.thermoYear;
    const hasPhotonic = params.photonicOn && year >= params.photonicYear;
    if (hasThermoCompute || hasPhotonic) {
      const deterministicFrac = 1 - params.workloadProbabilistic;
      const probFrac = params.workloadProbabilistic;
      const photonicMult = hasPhotonic ? params.photonicSpaceMult : 1;
      const thermoMult = hasThermoCompute ? params.thermoSpaceMult : 1;
      return baseEff * (photonicMult * deterministicFrac + thermoMult * probFrac);
    }
    return baseEff;
  }
  function getBandwidth(year, params) {
    return params.bandwidth * Math.pow(1 + params.bwGrowth, year - 2026);
  }
  function getLEOPower(year, params) {
    const t = year - 2026;
    const hasThermal = params.thermalOn && year >= params.thermalYear;
    const hasFission = params.fissionOn && year >= params.fissionYear;
    const hasFusion = params.fusionOn && year >= params.fusionYear;
    const launchCost = getLaunchCost(year, params);
    const isStarshipEra = launchCost < 200;

    // Nuclear power: independent of solar
    if (hasFission) {
      const fissionMaturity = Math.min(1, (year - params.fissionYear) / 10);
      const fissionPower = 10000 + fissionMaturity * 40000; // 10 MW → 50 MW
      if (hasFusion) {
        // Fusion: 100-500 MW for LEO platforms
        const fusionMaturity = Math.min(1, (year - params.fusionYear) / 10);
        const fusionPower = 100000 + fusionMaturity * 400000; // 100 MW → 500 MW
        return Math.max(fusionPower, fissionPower);
      }
      return fissionPower;
    }

    // Solar power: limited by panel area/mass and thermal rejection
    if (isStarshipEra && hasThermal) {
      const thermalMaturity = Math.min(1, (year - 2030) / 10);
      return 2000 + thermalMaturity * 18000; // 2 MW → 20 MW
    } else if (isStarshipEra) {
      const starshipMaturity = Math.min(1, (year - 2030) / 10);
      return 1000 + starshipMaturity * 4000; // 1 MW → 5 MW
    } else if (hasThermal) {
      const thermalMaturity = Math.min(1, (year - params.thermalYear) / 6);
      return 500 + thermalMaturity * 1500; // 500 kW → 2 MW
    }
    // Pre-Starship baseline
    return Math.min(500, params.initPower + t * 15); // 120 kW → 500 kW
  }
  function getCislunarPower(year, params) {
    const hasFission = params.fissionOn && year >= params.fissionYear;
    const hasFusion = params.fusionOn && year >= params.fusionYear;
    const hasThermal = params.thermalOn && year >= params.thermalYear;
    if (hasFusion) {
      // Fusion: 1 GW → 10 GW cislunar stations (kW)
      const fusionMaturity = Math.min(1, (year - params.fusionYear) / 10);
      return 1000000 + fusionMaturity * 9000000;
    }
    if (hasFission) {
      // Fission: 50 MW → 150 MW platforms (kW)
      return 50000 + Math.min(1, (year - params.fissionYear) / 10) * 100000;
    }
    if (hasThermal && year - params.thermalYear >= 5) {
      // Thermal only: 1 MW → 2 MW (barely viable)
      const maturity = Math.min(1, (year - params.thermalYear - 5) / 5);
      return 1000 + maturity * 1000;
    }
    return 0;
  }

  // src/model/orbital.ts
  function getShellRadiationEffects(shell, year, params) {
    const shellData = SHELLS[shell];
    const t = year - 2026;
    const tidFactor = shellData.tidMult;
    const effectiveLife = params.satLife / tidFactor;
    const radHardBase = 0.82 + params.radPen * 0.1;
    const radHardImprovement = Math.pow(radHardBase, t);
    const seuPenalty = 1 + (shellData.seuMult - 1) * radHardImprovement;
    const availabilityFactor = 1 / seuPenalty;
    const baseReplacement = 1 / effectiveLife;
    const replacementRate = Math.min(0.3, baseReplacement);
    return {
      tidFactor,
      effectiveLife,
      seuPenalty,
      availabilityFactor,
      replacementRate
    };
  }

  // src/model/finance.ts
  function getCRF(wacc, years) {
    if (wacc <= 0 || years <= 0) return 1 / Math.max(1, years);
    const r = wacc;
    const n = years;
    const factor = Math.pow(1 + r, n);
    return r * factor / (factor - 1);
  }

  // src/model/satellite.ts
  var H100_TFLOPS = 1979;
  var H100_WATTS = 700;
  var H100_GFLOPS_W = H100_TFLOPS * 1e3 / H100_WATTS;
  function getPlatformMass(year, params, forcedPowerSource = null) {
    // Platform mass depends on:
    // 1. Launch vehicle (Starship enables larger platforms)
    // 2. Thermal capability (droplet radiators enable more power density)
    // 3. Power source (only if fission/fusion is ACTUALLY selected, not just available)
    const hasThermal = params.thermalOn && year >= params.thermalYear;
    const starshipYear = params.starshipOn ? (params.starshipYear || 2029) : 2100;
    const hasStarship = params.starshipOn && year >= starshipYear;
    const t = year - 2026;

    // Only use fission/fusion mass if that power source is actually selected
    if (forcedPowerSource === 'fusion') {
      const fusionMaturity = Math.min(1, (year - params.fusionYear) / 15);
      return 2e5 + fusionMaturity * 8e5;  // 200-1000 tonnes for fusion stations
    }
    if (forcedPowerSource === 'fission') {
      const fissionMaturity = Math.min(1, (year - params.fissionYear) / 15);
      return 5e4 + fissionMaturity * 15e4;  // 50-200 tonnes for fission platforms
    }

    // Solar platforms - size limited by launch vehicle and thermal rejection
    if (hasStarship) {
      const starshipMaturity = Math.min(1, (year - starshipYear) / 3);
      if (hasThermal) {
        // THERMAL BREAKTHROUGH IS HUGE:
        // Without thermal: limited to ~200kW by heat rejection (conventional radiators too heavy)
        // With thermal: droplet radiators enable MW-class platforms
        // Starship can lift 100-150t to LEO - thermal is no longer the limit
        const thermalMaturity = Math.min(1, (year - params.thermalYear) / 5);
        return 5e3 + starshipMaturity * 15e3 + thermalMaturity * 30e3;  // 5-50 tonnes with thermal
      }
      // Without thermal breakthrough: heat rejection limits platform size severely
      return 3e3 + starshipMaturity * 5e3;  // 3-8 tonnes without thermal (thermally limited)
    }
    // Pre-Starship: small satellites (Falcon 9 limited to ~2t useful payload)
    return Math.min(2e3, 1500 + t * 150);
  }
  function getSolarMassPerKw(year, params) {
    const t = year - 2026;
    // Solar panel areal density: 2.0 kg/m² (thin-film, Starlink V2 ~2.3 kg/m²)
    // Specific power = (efficiency * solar_constant) / areal_density
    // At 20% eff: 0.20 * 1361 / 2.0 = 136 W/kg
    const arealDensity = 2.0; // kg/m² - realistic thin-film panels
    const baseWPerKg = (params.solarEff * 1361) / arealDensity;
    const learningMult = Math.pow(1 + params.solarLearn, t);
    const wPerKg = Math.min(400, baseWPerKg * learningMult);
    return 1e3 / wPerKg;
  }
  function getFissionMassPerKw(year, params) {
    // Fission specific power: 50 W/kg (MegaPower-class, includes radiators)
    // Note: Kilopower is only ~7 W/kg, MegaPower targets ~50 W/kg
    // Mass per kW = 1000 W/kW / 50 W/kg = 20 kg/kW
    // Improves to ~33 W/kg over 15 years → 30 kg/kW
    if (!params.fissionOn || year < params.fissionYear) return Infinity;
    const maturity = Math.min(1, (year - params.fissionYear) / 15);
    const specificPower = 50 + maturity * 17; // 50 → 67 W/kg
    return 1000 / specificPower; // 20 → 15 kg/kW
  }
  function getFusionMassPerKw(year, params) {
    // Fusion specific power: 250 W/kg (theoretical compact reactor)
    // Mass per kW = 1000 W/kW / 250 W/kg = 4 kg/kW
    // Improves to ~500 W/kg over 15 years → 2 kg/kW
    if (!params.fusionOn || year < params.fusionYear) return Infinity;
    const maturity = Math.min(1, (year - params.fusionYear) / 15);
    const specificPower = 250 + maturity * 250; // 250 → 500 W/kg
    return 1000 / specificPower; // 4 → 2 kg/kW
  }
  function getRadiatorPhysics(year, params) {
    // PHYSICS-BASED RADIATOR CALCULATION
    // Stefan-Boltzmann: P = εσT⁴
    // At 350K: 723 W/m² per side, ~1200 W/m² two-sided after backside absorption
    const hasThermal = params.thermalOn && year >= params.thermalYear;
    const t = year - 2026;
    const baseTemp = params.opTemp || 365;

    // Temperature: thermal breakthrough enables higher operating temps
    const opTemp = hasThermal
      ? Math.min(450, baseTemp + (year - params.thermalYear) * 8)  // Up to 450K with droplet radiators
      : Math.max(320, baseTemp - 30);  // Limited without thermal tech

    const emittedWPerM2 = params.emissivity * STEFAN_BOLTZMANN * Math.pow(opTemp, 4);
    const twoSidedEmission = 2 * emittedWPerM2;

    // Backside absorption from Earth IR and albedo
    const attitudeQuality = hasThermal ? 0.85 : 0.5;
    const backsideAbsorbed = 350 * (1 - attitudeQuality) + 80 * attitudeQuality;
    const netWPerM2 = twoSidedEmission - backsideAbsorbed;

    // Areal density (kg/m²) - THIS IS THE KEY DIFFERENCE
    // Conventional heat pipes: 5-10 kg/m² → 3000-7000 kg/MW
    // Droplet radiators: 0.3-0.5 kg/m² → 50-200 kg/MW (10-100x lighter!)
    let kgPerM2;
    if (hasThermal) {
      // Droplet radiators: 0.5 kg/m² initially, improving to 0.3 kg/m²
      const maturity = Math.min(1, (year - params.thermalYear) / 8);
      kgPerM2 = 0.5 - maturity * 0.2;  // 0.5 → 0.3 kg/m²
    } else {
      // Conventional heat pipe radiators: 8-5 kg/m² with slow improvement
      kgPerM2 = Math.max(5.0, 8.0 - t * 0.15);
    }

    // kg per kW of thermal rejection
    const kgPerKwThermal = kgPerM2 / netWPerM2 * 1e3;
    return { netWPerM2, kgPerM2, kgPerKwThermal };
  }
  function getComputeEfficiency(year, params) {
    const t = year - 2026;
    const hasThermal = params.thermalOn && year >= params.thermalYear;
    const hasThermoCompute = params.thermoOn && year >= params.thermoYear;
    const hasPhotonicCompute = params.photonicOn && year >= params.photonicYear;
    let baseGflopsW = H100_GFLOPS_W;
    for (let y = 2026; y < year; y++) {
      const yearsOut = y - 2026;
      const annualImprovement = Math.max(0.03, params.aiLearn - yearsOut * 5e-3);
      baseGflopsW *= 1 + annualImprovement;
    }
    const maxMult = Math.min(8, 1 + t * 0.16);
    baseGflopsW = Math.min(baseGflopsW, H100_GFLOPS_W * maxMult);
    const startingEfficiency = 1 - params.radPen;
    const improvement = t * 0.012;
    const radHardPenalty = Math.min(0.98, startingEfficiency + improvement);
    let gflopsW = baseGflopsW * radHardPenalty;

    // THERMAL BREAKTHROUGH EFFICIENCY BONUS
    // Without proper cooling: chips thermal throttle, run at 70-80% of rated power
    // With droplet radiators: chips run at full rated power, no throttling
    // This is a ~25-40% efficiency improvement from thermal alone
    if (hasThermal) {
      const thermalMaturity = Math.min(1, (year - params.thermalYear) / 5);
      const thermalBonus = 1.25 + thermalMaturity * 0.15;  // 1.25x → 1.40x efficiency
      gflopsW *= thermalBonus;
    }

    if (hasThermoCompute || hasPhotonicCompute) {
      const deterministicFrac = 1 - params.workloadProbabilistic;
      const probFrac = params.workloadProbabilistic;
      const photonicMult = hasPhotonicCompute ? params.photonicSpaceMult : 1;
      const thermoMult = hasThermoCompute ? params.thermoSpaceMult : 1;
      gflopsW *= photonicMult * deterministicFrac + thermoMult * probFrac;
    }
    return { gflopsW, radHardPenalty };
  }
  function getUtilization(year, params) {
    const t = year - 2026;
    const hasFission = params.fissionOn && year >= params.fissionYear;
    const maturityFactor = Math.min(0.92, 0.5 + t * 0.105);
    const eclipseFactor = hasFission ? 0.95 : 0.88;
    const opsFactor = 0.95;
    return maturityFactor * eclipseFactor * opsFactor;
  }
  function calcSatellite(year, params, shell = "leo") {
    const t = year - 2026;
    const hasThermal = params.thermalOn && year >= params.thermalYear;
    const hasFission = params.fissionOn && year >= params.fissionYear;
    const hasFusion = params.fusionOn && year >= params.fusionYear;
    const hasThermoCompute = params.thermoOn && year >= params.thermoYear;
    const hasPhotonicCompute = params.photonicOn && year >= params.photonicYear;
    const targetMassKg = getPlatformMass(year, params);
    const structureFrac = hasFission ? 0.1 : 0.15;
    const otherSystemsFrac = hasFission ? 0.08 : Math.max(0.12, 0.18 - t * 6e-3);
    const avionicsMassKg = 50;
    const availableMass = targetMassKg * (1 - structureFrac - otherSystemsFrac) - avionicsMassKg;
    const solarMassPerKw = getSolarMassPerKw(year, params);
    const fissionMassPerKw = hasFission ? getFissionMassPerKw(year, params) : Infinity;
    const fusionMassPerKw = hasFusion ? getFusionMassPerKw(year, params) : Infinity;

    // Calculate battery mass needed for solar (fission/fusion don't need batteries)
    const battDensEst = Math.min(500, params.battDens + t * 15);
    const eclipseDurationHrs = 0.5;
    const eclipseComputeFrac = 0.3;
    const batteryMassPerKwComputeSolar = eclipseComputeFrac * eclipseDurationHrs * 1e3 / battDensEst;
    // Convert to per-kW-power basis (multiply by computeFrac since batteries serve compute)
    const batteryMassPerKwPowerSolar = batteryMassPerKwComputeSolar * params.computeFrac;

    // Effective mass per kW including uptime factor AND battery mass for solar
    // Solar: 88% uptime due to eclipse, needs batteries
    // Fission: 95% uptime, no batteries needed
    // Fusion: 95% uptime, no batteries needed
    const solarTotalMassPerKw = solarMassPerKw + batteryMassPerKwPowerSolar;
    const solarEffectiveMassPerKw = solarTotalMassPerKw / 0.88;
    const fissionEffectiveMassPerKw = fissionMassPerKw / 0.95;
    const fusionEffectiveMassPerKw = fusionMassPerKw / 0.95;

    let powerMassPerKw;
    let powerSource;
    if (hasFusion && fusionEffectiveMassPerKw < fissionEffectiveMassPerKw && fusionEffectiveMassPerKw < solarEffectiveMassPerKw) {
      powerMassPerKw = fusionMassPerKw;
      powerSource = "fusion";
    } else if (hasFission && fissionEffectiveMassPerKw < solarEffectiveMassPerKw) {
      powerMassPerKw = fissionMassPerKw;
      powerSource = "fission";
    } else {
      powerMassPerKw = solarMassPerKw;
      powerSource = "solar";
    }
    const radPhysics = getRadiatorPhysics(year, params);
    const wasteHeatFrac = 0.95;
    const radiatorMassPerKwCompute = radPhysics.kgPerKwThermal * wasteHeatFrac;

    // COMPUTE MASS: Thermal breakthrough enables denser packing
    // Without thermal: spread out chips to avoid hot spots, 35→25 kg/kW
    // With thermal: efficient cooling allows 30% denser packing, 25→18 kg/kW
    let computeMassPerKw;
    if (hasThermal) {
      const thermalMaturity = Math.min(1, (year - params.thermalYear) / 5);
      computeMassPerKw = Math.max(18, 25 - thermalMaturity * 7);  // 25→18 kg/kW with thermal
    } else {
      computeMassPerKw = Math.max(25, 35 - t * 1);  // 35→25 kg/kW without thermal
    }
    const battDens = Math.min(500, params.battDens + t * 15);
    // eclipseDurationHrs and base eclipseComputeFrac already defined above for power source selection
    const actualEclipseComputeFrac = hasFission ? 0 : 0.3;  // Fission doesn't need eclipse batteries
    const batteryMassPerKwCompute = hasFission ? 0 : actualEclipseComputeFrac * eclipseDurationHrs * 1e3 / battDens;
    const totalMassPerKwCompute = powerMassPerKw / params.computeFrac + // Power system sized for total platform power
    radiatorMassPerKwCompute + computeMassPerKw + batteryMassPerKwCompute;
    const computeKw = availableMass / totalMassPerKwCompute;
    const powerKw = computeKw / params.computeFrac;
    const powerMass = powerKw * powerMassPerKw;
    const radiatorMass = computeKw * radiatorMassPerKwCompute;
    const computeMass = computeKw * computeMassPerKw;
    const battMass = computeKw * batteryMassPerKwCompute;
    const structMass = targetMassKg * structureFrac;
    const otherMass = targetMassKg * otherSystemsFrac;
    const dryMass = targetMassKg;
    const powerMassPerKwCompute = powerMassPerKw / params.computeFrac;
    const thermalMassPerKwCompute = radiatorMassPerKwCompute;
    let bindingConstraint;
    if (thermalMassPerKwCompute > powerMassPerKwCompute && thermalMassPerKwCompute > computeMassPerKw) {
      bindingConstraint = "thermal";
    } else if (powerMassPerKwCompute > computeMassPerKw) {
      bindingConstraint = "power";
    } else {
      bindingConstraint = "mass";
    }
    const efficiency = getComputeEfficiency(year, params);
    const gflopsW = efficiency.gflopsW;
    const powerConversionEff = 0.85;
    const effectiveComputeKw = computeKw * powerConversionEff;
    const tflopsRaw = effectiveComputeKw * gflopsW;
    const radEffects = getShellRadiationEffects(shell, year, params);
    const utilization = getUtilization(year, params);
    const tflops = tflopsRaw * utilization * radEffects.availabilityFactor;
    const gpuEq = tflops / H100_TFLOPS;

    // =====================================================
    // CAPEX CALCULATION - First Principles Component Costs
    // =====================================================
    // Each component has its own $/kg based on research:
    // - Solar panels: $500/kg (Starlink-style mass production)
    // - Batteries: $200/kg (Li-ion commodity)
    // - Compute modules: $25,000/kg (rad-hard GPUs, most expensive!)
    // - Radiators: $3,000/kg (specialized thermal)
    // - Structure: $1,500/kg (composites)
    // - Avionics: $80,000/kg (but only 50kg = $4M fixed)
    // - Other systems: $7,000/kg (propulsion, comm, etc.)
    //
    // Learning curves bring these down over time (Wright's Law)

    // Manufacturing learning rate (compounds annually based on demand)
    // prodMult = initial production inefficiency (2.5 = 2.5× cost premium for early production)
    // Learning reduces this over time based on demand pressure (Wright's Law)
    // THE CORE THESIS: High demand drives massive investment -> faster learning
    const initialProdMult = params.prodMult || 2.5;
    let learnMult = initialProdMult;
    for (let y = 2026; y < year; y++) {
      const demandPressure = getDemandPressure(y, params);
      // Learning rate scales with demand pressure:
      // - At demand=supply (1.0): 10% annual learning
      // - At 2x demand (2.0): 15% annual learning
      // - At 5x demand (5.0): 25% annual learning (extreme scarcity drives massive R&D)
      const normalizedPressure = Math.max(0, (demandPressure - 1) / 4); // 0 at 1.0, 1 at 5.0
      const annualReduction = 0.10 + 0.15 * normalizedPressure;
      learnMult *= (1 - annualReduction);
    }
    // Floor scales with initial prodMult - scenarios with different starting points stay different
    const learnFloor = 0.15 * (initialProdMult / 2.5);
    learnMult = Math.max(learnFloor, learnMult);

    // Apply manufacturing cost multiplier from slider (default 1.0)
    const mfgMult = params.mfgCostMult || 1.0;

    // Component costs ($/kg) - 2026 baseline before learning
    // These drop with learnMult over time
    const COMPONENT_COSTS_2026 = {
      solar: 500,      // $/kg - mass production solar panels
      battery: 200,    // $/kg - Li-ion commodity pricing
      compute: 25000,  // $/kg - rad-hard compute (the expensive part!)
      radiator: 3000,  // $/kg - specialized thermal systems
      structure: 1500, // $/kg - composite structures
      avionics: 80000, // $/kg - but only 50kg fixed mass
      other: 7000      // $/kg - propulsion, comm, etc.
    };

    // Apply learning curve and slider multiplier to each component
    // TECHNOLOGY DISCOUNTS:
    // Thermal breakthrough: droplet radiators are simpler/cheaper than heat pipes
    //                       AND compute can use simpler thermal packaging
    // Fission/Fusion: compact reactors reduce power system costs
    let powerDiscount = 1.0;
    let thermalDiscount = 1.0;
    let computeThermalDiscount = 1.0;

    // Thermal breakthrough makes radiators MUCH cheaper (droplets vs heat pipes)
    // AND compute hardware can use simpler thermal packaging
    if (hasThermal) {
      const thermalMaturity = Math.min(1, (year - params.thermalYear) / 5);
      thermalDiscount = 0.5 - thermalMaturity * 0.3;  // 50% → 20% of conventional radiator cost
      // Compute can use simpler packaging when thermal isn't the constraint
      // Don't need exotic materials, vapor chambers, heat spreaders on every chip
      computeThermalDiscount = 0.7 - thermalMaturity * 0.2;  // 70% → 50% of compute thermal overhead
    }

    // Nuclear power discounts (override thermal discount if better)
    if (hasFusion) {
      powerDiscount = 0.05;   // 95% reduction - fusion is nearly free power
      thermalDiscount = Math.min(thermalDiscount, 0.10); // 90% reduction - fusion has built-in cooling
    } else if (hasFission) {
      powerDiscount = 0.40;   // 60% reduction - fission is compact but not free
      thermalDiscount = Math.min(thermalDiscount, 0.30); // 70% reduction - fission has integrated cooling
    }

    const compCosts = {
      solar: COMPONENT_COSTS_2026.solar * learnMult * mfgMult * powerDiscount,
      battery: COMPONENT_COSTS_2026.battery * learnMult * mfgMult * powerDiscount,
      compute: COMPONENT_COSTS_2026.compute * learnMult * mfgMult * computeThermalDiscount,  // Thermal simplifies packaging
      radiator: COMPONENT_COSTS_2026.radiator * learnMult * mfgMult * thermalDiscount,
      structure: COMPONENT_COSTS_2026.structure * learnMult * mfgMult,
      avionics: COMPONENT_COSTS_2026.avionics * learnMult * mfgMult,
      other: COMPONENT_COSTS_2026.other * learnMult * mfgMult
    };

    // Calculate manufacturing cost from component masses
    const mfgCostSolar = powerMass * compCosts.solar;
    const mfgCostBatt = battMass * compCosts.battery;
    const mfgCostCompute = computeMass * compCosts.compute;
    const mfgCostRadiator = radiatorMass * compCosts.radiator;
    const mfgCostStruct = structMass * compCosts.structure;
    const mfgCostAvionics = avionicsMassKg * compCosts.avionics;
    const mfgCostOther = otherMass * compCosts.other;

    const totalMfgCost = mfgCostSolar + mfgCostBatt + mfgCostCompute +
                         mfgCostRadiator + mfgCostStruct + mfgCostAvionics + mfgCostOther;

    // Launch cost
    const launchCostPerKg = getLaunchCost(year, params, shell);
    const launchCost = dryMass * launchCostPerKg;

    // Integration & test (60% of hardware cost - industry standard for space systems)
    // This includes assembly, environmental testing, quality assurance, launch prep
    const integrationCost = totalMfgCost * 0.60;

    // Total CAPEX = launch + manufacturing + integration
    const capex = launchCost + totalMfgCost + integrationCost;

    // LCOC with full operational costs
    const crf = getCRF(params.waccOrbital, radEffects.effectiveLife);
    const annualCapex = capex * crf;
    const annualMaint = capex * params.maintCost;

    // Data rate and bandwidth operational costs
    const dataRateGbps = tflops * params.gbpsPerTflop;
    // bwCost is in $k/Gbps/year - this is the cost of laser relay bandwidth backhaul
    const annualBwCost = dataRateGbps * (params.bwCost || 50) * 1000; // Convert $k to $

    // Total annual cost = capex amortization + maintenance + bandwidth backhaul
    const annual = annualCapex + annualMaint + annualBwCost;
    const gpuHrs = gpuEq * 8760 * SLA;
    const lcoc = gpuHrs > 0 ? annual / gpuHrs : Infinity;
    const specPower = powerKw * 1e3 / dryMass;
    const solarWperM2 = Math.min(300, 150 + t * 10);
    const solarArea = powerSource === "solar" ? powerKw * 1e3 / solarWperM2 : 0;
    const radPower = params.emissivity * STEFAN_BOLTZMANN * Math.pow(params.opTemp, 4);
    let manufacturingCarbonKg;
    if (hasFusion) {
      const otherMass2 = dryMass - powerMass;
      manufacturingCarbonKg = powerMass * 300 + otherMass2 * 95;
    } else if (hasFission) {
      const otherMass2 = dryMass - powerMass;
      manufacturingCarbonKg = powerMass * 250 + otherMass2 * 95;
    } else {
      const otherMass2 = dryMass - powerMass;
      manufacturingCarbonKg = powerMass * 80 + otherMass2 * 95;
    }
    let launchCarbonPerKg;
    if (year < 2029) {
      launchCarbonPerKg = 60;
    } else {
      const greenMethaneFrac = Math.min(0.9, (year - 2029) * 0.08);
      const baseLaunchCarbon = 100;
      launchCarbonPerKg = baseLaunchCarbon * (1 - greenMethaneFrac);
    }
    const launchCarbonKg = dryMass * launchCarbonPerKg;
    const carbonKg = manufacturingCarbonKg + launchCarbonKg;
    const carbonPerTflop = carbonKg * 1e3 / Math.max(1, tflops * 8760 * radEffects.effectiveLife * 0.88);
    const carbonPerDollar = lcoc > 0 ? carbonPerTflop / lcoc : 0;
    const erol = powerKw * 1e3 * 8760 * 3600 * radEffects.effectiveLife * 0.88 / (dryMass * 4e8);
    const mass = {
      power: powerMass,
      batt: battMass,
      comp: computeMass,
      rad: radiatorMass,
      struct: structMass
    };
    return {
      year,
      powerKw,
      dryMass,
      tflops,
      gpuEq,
      capex,
      lcoc,
      erol,
      carbonPerTflop,
      carbonPerDollar,
      gflopsW,
      radPower,
      specPower,
      solarArea,
      dataRateGbps,
      shell,
      mass,
      hasThermal,
      hasFission,
      hasFusion,
      hasThermoCompute,
      hasPhotonicCompute,
      powerSource,  // Actual power source selected (solar/fission/fusion)
      radMassPerMW: radiatorMassPerKwCompute * 1e3,
      radEffects,
      bindingConstraint,
      utilization,
      computeKw,
      tflopsRaw
    };
  }

  // src/model/ground.ts
  function calcGround(year, orbitalSupplyGW, params) {
    const t = year - 2026;
    const gflopsW = getGroundEfficiency(year, params);

    const hasSmr = params.smrOn && year >= params.smrYear;
    const hasFusion = params.fusionOn && year >= params.fusionYear;

    // Energy discounts from advanced nuclear (SMR or fusion)
    // SMR: starts at 70% of grid cost, drops to 40% over 10 years
    // Fusion: starts at 15% of grid cost, drops to 5% over 10 years (near-free energy!)
    const smrDiscount = hasSmr ? Math.max(0.4, 0.7 - (year - params.smrYear) * 0.03) : 1;
    const fusionDiscount = hasFusion ? Math.max(0.05, 0.15 - (year - params.fusionYear) * 0.01) : 1;
    const nuclearDiscount = Math.min(smrDiscount, fusionDiscount);

    const yearBtmShare = getBtmShare(year, params);

    // Hardware cost with WACC/CRF
    // GPU price declines ~16%/year (Moore's Law + competition)
    const gpuPrice = 25000 * Math.pow(0.84, t);
    // Server overhead (chassis, networking, power supplies) = 1.5x raw GPU cost
    // Note: CRF handles depreciation, not /3
    const hwCapex = (gpuPrice * 1.5) / (gflopsW / 2800);

    const btmCapexOverhead = yearBtmShare * (params.btmCapexMult - 1);
    const hwCapexAdjusted = hwCapex * (1 + btmCapexOverhead);
    const groundHwLife = 5;
    const crfGround = getCRF(params.waccGround, groundHwLife);
    const hwCost = hwCapexAdjusted * crfGround;

    // Blended energy costs (grid vs BTM)
    // Nuclear discount applies to GRID energy only (BTM is solar+storage, stable cost)
    const gridEnergy = params.energyCost * Math.pow(1 + params.energyEscal, t) * nuclearDiscount;
    const btmEnergy = params.btmEnergyCost; // BTM is solar+storage - no nuclear discount
    const blendedEnergy = gridEnergy * (1 - yearBtmShare) + btmEnergy * yearBtmShare;

    const pue = Math.max(1.08, params.groundPue - t * 0.01);
    const enCost = 700 * 8760 * SLA * blendedEnergy * pue / 1e3;
    // Overhead includes: cooling, staffing, land lease, insurance, network, security
    // $0.50/GPU-hr is realistic for hyperscale operations
    const overhead = 0.50 * 8760 * SLA;
    // Utilization factor: datacenters don't run at 100% - typical 60-80%
    const utilization = 0.70;
    const base = (hwCost + enCost + overhead) / (8760 * SLA * utilization);

    // Market dynamics - use total supply including orbital
    const demand = getDemand(year, params);
    const groundSupply = getGroundSupply(year, params);
    const totalSupply = groundSupply + orbitalSupplyGW;
    const unmetRatio = (demand - totalSupply) / totalSupply;

    // SCARCITY PREMIUM - THE CORE THESIS
    // When demand >> supply, ground compute prices skyrocket due to scarcity
    // This is what makes orbital compute viable: ground scarcity drives prices up
    // unmetRatio = (demand - supply) / supply
    //   = 0: demand equals supply (baseline pricing)
    //   = 1: demand is 2x supply (severe shortage)
    //   = 9: demand is 10x supply (extreme scarcity)
    let premium;
    if (unmetRatio <= -0.3) {
      // Severe oversupply: price war (floor at 0.6x cost)
      premium = Math.max(0.6, 0.85 + unmetRatio);
    } else if (unmetRatio <= 0) {
      // Mild oversupply: slight discount
      premium = 1.0 + unmetRatio * 0.5;
    } else if (unmetRatio <= 0.3) {
      // Moderate scarcity: linear premium
      premium = 1 + unmetRatio * 4;
    } else if (unmetRatio <= 1.0) {
      // High scarcity: slower growth (demand destruction kicks in)
      premium = 2.2 + (unmetRatio - 0.3) * 2.5;
    } else {
      // Extreme scarcity: logarithmic growth (demand destruction slows but doesn't stop price rise)
      // At 10x demand/supply (unmetRatio=9): ~6x premium
      // At 100x demand/supply (unmetRatio=99): ~10x premium
      // Prices keep rising with scarcity - no artificial cap
      premium = 4 + 2 * Math.log10(unmetRatio);
    }
    // Ground carbon intensity - blend of grid (natural gas/coal) and BTM (solar)
    // Grid: 380 gCO2/kWh in 2026, decaying 3%/year as grid greens
    // BTM: 30 gCO2/kWh (solar lifecycle emissions)
    const gridCarbon = 380 * Math.pow(0.97, t);  // gCO2/kWh
    const btmCarbon = 30;                         // gCO2/kWh (solar)
    const blendedCarbon = yearBtmShare * btmCarbon + (1 - yearBtmShare) * gridCarbon;

    // Operational carbon per TFLOP-hr:
    // - 1 TFLOP-hr = 1000 GFLOP-hr
    // - At gflopsW efficiency, need (1000 / gflopsW) Wh = (1 / gflopsW) kWh per TFLOP-hr
    // - With PUE overhead: (PUE / gflopsW) kWh per TFLOP-hr
    // - Carbon = blendedCarbon * (PUE / gflopsW) gCO2 per TFLOP-hr
    const kWhPerTflopHr = pue * 1000 / gflopsW;  // kWh per TFLOP-hr
    const operationalCarbon = blendedCarbon * kWhPerTflopHr;  // gCO2 per TFLOP-hr

    // Embodied carbon (manufacturing the hardware)
    // ~500 kgCO2 per kW of compute capacity, amortized over 5-year life
    const embodiedCarbonPerKwYear = 500 / 5;  // kgCO2/kW/year
    const embodiedCarbon = embodiedCarbonPerKwYear * 1e3 / (gflopsW * 8760);  // gCO2 per TFLOP-hr

    const carbonPerTflop = operationalCarbon + embodiedCarbon;
    const carbonPerDollar = carbonPerTflop / (base * premium);
    return {
      year,
      base,
      market: base * premium,
      premium,
      carbonPerTflop,
      carbonPerDollar,
      gflopsW,
      demand,
      groundSupply,
      totalSupply,
      unmetRatio
    };
  }

  // src/model/fleet.ts
  var TOKENS_PER_GPU_HR = 3600 * 100;

  // Track previous year's platforms for monotonic constraint
  // Once platforms are built, they stay built (may be underutilized but don't disappear)
  var prevLeoPlatforms = 0;
  var prevGeoPlatforms = 0;
  var prevCisPlatforms = 0;
  var prevLunarPlatforms = 0;

  function resetFleetTracker() {
    prevLeoPlatforms = 0;
    prevGeoPlatforms = 0;
    prevCisPlatforms = 0;
    prevLunarPlatforms = 0;
  }

  function getLunarPowerKw(year, params) {
    const hasFission = params.fissionOn && year >= params.fissionYear;
    const hasFusion = params.fusionOn && year >= params.fusionYear;
    if (!hasFission && !hasFusion) return 0;
    const maturity = Math.min(1, (year - Math.max(params.fissionYear, 2040)) / 10);
    if (hasFusion) {
      return 2e5 + maturity * 8e5;
    }
    return 1e5 + maturity * 4e5;
  }
  function calcFleet(year, crossoverYear, params) {
    const sat = calcSatellite(year, params);
    const cislunarPowerKw = getCislunarPower(year, params);
    const lunarPowerKw = getLunarPowerKw(year, params);
    const t = year - 2026;
    const hasFission = params.fissionOn && year >= params.fissionYear;
    const hasFusion = params.fusionOn && year >= params.fusionYear;
    const hasThermal = params.thermalOn && year >= params.thermalYear;
    let leoPlatforms = 0;
    let meoPlatforms = 0;
    let geoPlatforms = 0;
    let cisPlatforms = 0;
    let lunarPlatforms = 0;
    if (!crossoverYear || year < crossoverYear) {
      const yearsToGo = crossoverYear ? crossoverYear - year : 10;
      if (yearsToGo <= 3) {
        const rampYears = 3 - yearsToGo;
        leoPlatforms = Math.round(500 * Math.pow(2, rampYears));
      } else {
        leoPlatforms = Math.min(500, 50 + t * 30);
      }
    } else {
      const yearsPost = year - crossoverYear;
      // More realistic fleet growth: 2.5 year doubling (like aggressive but not insane infrastructure buildout)
      const doublingYears = params.fleetDoublingYears || 2.5;

      // Start with 1000 platforms at crossover, grow from there
      // Cap growth to match demand - don't build more than you can sell
      const maxFromGrowth = Math.round(1000 * Math.pow(2, yearsPost / doublingYears));

      // Get demand-based cap (don't build more capacity than eligible demand)
      const totalDemandGW = getDemand(year, params);
      const eligibleDemandGW = totalDemandGW * params.orbitalEligibleShare;
      const platformPowerGW = sat.powerKw / 1e6;
      const demandBasedCap = platformPowerGW > 0 ? Math.ceil(eligibleDemandGW / platformPowerGW * 1.2) : maxFromGrowth; // 20% buffer

      leoPlatforms = Math.min(
        SHELLS.leo.capacity,
        maxFromGrowth,
        demandBasedCap
      );

      const leoFull = leoPlatforms >= SHELLS.leo.capacity * 0.95;
      if (yearsPost >= 5) {
        const geoGrowthYears = yearsPost - 5;
        geoPlatforms = Math.min(
          SHELLS.geo.capacity,
          Math.round(50 * Math.pow(2, geoGrowthYears / 3)) // Slower: 3-year doubling
        );
      }
      if (cislunarPowerKw > 0 && yearsPost >= 4) { // Later start
        const cislunarGrowthYears = yearsPost - 4;
        cisPlatforms = Math.min(
          SHELLS.cislunar.capacity,
          Math.round(100 * Math.pow(2, cislunarGrowthYears / 2)) // Slower growth
        );
      }
      if (lunarPowerKw > 0 && yearsPost >= 8) { // Later start
        const lunarGrowthYears = yearsPost - 8;
        lunarPlatforms = Math.min(
          1e5,
          Math.round(20 * Math.pow(2, lunarGrowthYears / 2))
        );
      }
    }
    const totalDemandGW = getDemand(year, params);
    const ground = calcGround(year, 0, params);
    const costRatio = sat.lcoc / Math.max(0.01, ground.market);
    const eligibleMult = costRatio < 1 ? Math.min(2, 1 / costRatio) : 1;
    const dynamicEligibleShare = Math.min(0.7, params.orbitalEligibleShare * eligibleMult);
    const maxOrbitalDemandGW = totalDemandGW * dynamicEligibleShare;
    // Use physics-driven power (getLEOPower) for fleet calculations
    // This gives MW-class platforms with thermal/fission/fusion
    const leoKw = getLEOPower(year, params);
    // GEO power multiplier: fusion 50x, fission 20x, thermal 10x, baseline 5x (applied to LEO power)
    const geoKwCalc = hasFusion ? leoKw * 50 : hasFission ? leoKw * 20 : hasThermal ? leoKw * 10 : leoKw * 5;
    const uncFleetGW = (leoPlatforms * leoKw + geoPlatforms * geoKwCalc + cisPlatforms * cislunarPowerKw + lunarPlatforms * lunarPowerKw) / 1e6;

    // NOTE: Demand constraint removed - platforms are monotonic (once built, stay built)
    // When supply > demand, utilization drops (sellableUtil) but platforms don't disappear
    // This is more realistic: you don't scrap satellites just because demand is soft

    // Launch capacity constraint - dynamic scaling matches fleet.ts
    // Based on Elon's projections: 10k flights/year is reasonable by 2035
    function getMaxLaunchesPerYear(y) {
      if (y <= 2026) return 500;
      if (y <= 2028) return Math.round(500 + ((y - 2026) / 2) * 1500); // 500 → 2000
      if (y <= 2030) return Math.round(2000 + ((y - 2028) / 2) * 3000); // 2000 → 5000
      if (y <= 2035) return Math.round(5000 + ((y - 2030) / 5) * 5000); // 5000 → 10000
      if (y <= 2040) return Math.round(10000 + ((y - 2035) / 5) * 5000); // 10000 → 15000
      return Math.round(15000 + Math.min(1, (y - 2040) / 10) * 5000); // 15000 → 20000
    }
    const MAX_LAUNCHES_PER_YEAR = getMaxLaunchesPerYear(year);
    const STARSHIP_PAYLOAD_KG = 150000;
    const totalPlatformsPreLaunch = leoPlatforms + geoPlatforms + cisPlatforms + lunarPlatforms;
    const annualMassKg = totalPlatformsPreLaunch * sat.dryMass * 0.15; // ~15% fleet replacement + new builds
    const requiredFlights = annualMassKg / STARSHIP_PAYLOAD_KG;
    let launchConstrained = false;
    if (requiredFlights > MAX_LAUNCHES_PER_YEAR) {
      launchConstrained = true;
      const launchScale = MAX_LAUNCHES_PER_YEAR / requiredFlights;
      leoPlatforms = Math.round(leoPlatforms * launchScale);
      geoPlatforms = Math.round(geoPlatforms * launchScale);
      cisPlatforms = Math.round(cisPlatforms * launchScale);
      lunarPlatforms = Math.round(lunarPlatforms * launchScale);
    }

    // MONOTONIC CONSTRAINT: Platforms once built stay built
    // Can't have fewer platforms than last year (satellites don't just disappear)
    // Growth is limited by launch capacity, but existing fleet is preserved
    leoPlatforms = Math.max(leoPlatforms, prevLeoPlatforms);
    geoPlatforms = Math.max(geoPlatforms, prevGeoPlatforms);
    cisPlatforms = Math.max(cisPlatforms, prevCisPlatforms);
    lunarPlatforms = Math.max(lunarPlatforms, prevLunarPlatforms);

    // Update trackers for next year
    prevLeoPlatforms = leoPlatforms;
    prevGeoPlatforms = geoPlatforms;
    prevCisPlatforms = cisPlatforms;
    prevLunarPlatforms = lunarPlatforms;

    // GEO power uses same multipliers as above (applied to physics-driven LEO power)
    const geoPowerKw = geoKwCalc;  // Already calculated above
    const leoPowerTw = leoPlatforms * leoKw / 1e9;
    const meoPowerTw = 0;
    const geoPowerTw = geoPlatforms * geoPowerKw / 1e9;
    const cisPowerTw = cisPlatforms * cislunarPowerKw / 1e9;
    const lunarPowerTw = lunarPlatforms * lunarPowerKw / 1e9;
    const totalPowerTw = leoPowerTw + geoPowerTw + cisPowerTw + lunarPowerTw;
    // TFLOPS per platform based on physics-driven power
    const leoTflopsPerPlatform = leoKw * params.computeFrac * sat.gflopsW;
    const geoTflopsPerPlatform = geoPowerKw * params.computeFrac * sat.gflopsW;
    const cisTflopsPerPlatform = cislunarPowerKw * params.computeFrac * sat.gflopsW;
    const lunarTflopsPerPlatform = lunarPowerKw * params.computeFrac * sat.gflopsW;
    const fleetTflopsRaw = leoPlatforms * leoTflopsPerPlatform + geoPlatforms * geoTflopsPerPlatform + cisPlatforms * cisTflopsPerPlatform + lunarPlatforms * lunarTflopsPerPlatform;
    const cislunarLocalRatio = 0.97;
    const lunarLocalRatio = 0.99;
    const bwNeededLeo = leoPlatforms * leoTflopsPerPlatform * params.gbpsPerTflop;
    const bwNeededGeo = geoPlatforms * geoTflopsPerPlatform * params.gbpsPerTflop;
    const bwNeededCis = cisPlatforms * cisTflopsPerPlatform * params.gbpsPerTflop * (1 - cislunarLocalRatio);
    const bwNeededLunar = lunarPlatforms * lunarTflopsPerPlatform * params.gbpsPerTflop * (1 - lunarLocalRatio);
    const bwNeededGbps = bwNeededLeo + bwNeededGeo + bwNeededCis + bwNeededLunar;
    const bwAvailTbps = getBandwidth(year, params);
    const bwAvailGbps = bwAvailTbps * 1e3;
    const bwSell = bwNeededGbps <= 0 ? 1 : Math.min(1, bwAvailGbps / bwNeededGbps);
    const eligibleDemandGW = maxOrbitalDemandGW;
    const fleetPowerGW = totalPowerTw * 1e3;
    const demandSell = fleetPowerGW <= 0 ? 1 : Math.min(1, eligibleDemandGW / fleetPowerGW);
    const sellableUtil = Math.min(bwSell, demandSell);
    const lcocEffective = sat.lcoc / Math.max(0.01, sellableUtil);
    const deliveredTflops = fleetTflopsRaw * sellableUtil;
    const deliveredGpuEq = deliveredTflops / 1979;
    const deliveredPetaflopsEffective = deliveredTflops / 1e3;
    const deliveredGpuHrsPerYear = deliveredGpuEq * 8760 * 0.999;
    const deliveredTokensPerYear = deliveredGpuHrsPerYear * TOKENS_PER_GPU_HR;
    const bwUtil = bwAvailGbps > 0 ? Math.min(1, bwNeededGbps / bwAvailGbps) : 1;
    const demandUtil = eligibleDemandGW > 0 ? Math.min(1, fleetPowerGW / eligibleDemandGW) : 0;
    const leoUtil = leoPlatforms / SHELLS.leo.capacity;
    const meoUtil = 0;
    const geoUtil = geoPlatforms / SHELLS.geo.capacity;
    const cisUtil = cisPlatforms / Math.max(1, SHELLS.cislunar.capacity);
    const lunarUtil = lunarPlatforms / 1e4;
    // Bottleneck detection: identify the tightest constraint
    // Pre-thermal-breakthrough: no advanced heat rejection → thermal limits compute
    const preThermalBreakthrough = !sat.hasThermal && !sat.hasFission && !sat.hasFusion;
    let bottleneck = "power";
    if (preThermalBreakthrough) {
      // Before 2030 (thermal breakthrough): thermal rejection is the binding constraint
      bottleneck = "thermal";
    } else if (!crossoverYear || year < crossoverYear) {
      // Post-breakthrough but pre-crossover: use satellite's binding constraint
      bottleneck = sat.bindingConstraint || "power";
    } else {
      // Post-crossover: check constraints
      // BANDWIDTH check comes FIRST - it directly affects delivered tokens (revenue)
      if (bwSell < 0.95) {
        bottleneck = "bandwidth";
      } else if (launchConstrained) {
        // Launch capacity is limiting fleet growth (but not revenue from existing fleet)
        bottleneck = "launch_capacity";
      } else if (demandSell < 0.9) {
        bottleneck = "demand";
      } else if (leoUtil > 0.95 && geoUtil > 0.9) {
        bottleneck = "slots";
      } else {
        bottleneck = sat.bindingConstraint || "power";
      }
    }
    const leoRadEffects = getShellRadiationEffects("leo", year, params);
    const replacementRate = leoRadEffects.replacementRate;
    return {
      year,
      leoPlatforms,
      meoPlatforms,
      geoPlatforms,
      cisPlatforms,
      lunarPlatforms,
      leoPowerTw,
      meoPowerTw,
      geoPowerTw,
      cisPowerTw,
      lunarPowerTw,
      totalPowerTw,
      lcocEffective,
      bwUtil,
      bwAvailGbps,
      bwNeededGbps,
      bwSell,
      demandUtil,
      demandSell,
      eligibleDemandGW,
      fleetTflops: fleetTflopsRaw,
      fleetGpuEq: fleetTflopsRaw / 1979,
      sellableUtil,
      satPowerKw: sat.powerKw,
      cislunarPowerKw,
      lunarPowerKw,
      leoUtil,
      meoUtil,
      geoUtil,
      cisUtil,
      lunarUtil,
      bottleneck,
      replacementRate,
      // Delivered compute
      deliveredTflops,
      deliveredGpuEq,
      deliveredTokensPerYear,
      deliveredPetaflopsEffective
    };
  }

  // src/state/params.ts
  var defaults = {
    // Breakthroughs
    thermalOn: true,
    thermalYear: 2029,
    // Thermal breakthrough coincides with Starship
    starshipOn: true,
    starshipYear: 2029,
    // Starship enables 5-10× larger satellites and $200→$10/kg launch
    fissionOn: true,
    fissionYear: 2035,
    // Space nuclear enables cislunar operations
    fusionOn: false,
    // Fusion power - speculative, disabled by default
    fusionYear: 2050,
    // Fusion power for GW-class stations (if enabled)
    smrOn: true,
    smrYear: 2032,
    // Ground SMR deployment
    thermoOn: false,
    thermoYear: 2029,
    // Thermodynamic computing availability
    thermoGroundMult: 1e3,
    // Room-temp TSU efficiency multiplier
    thermoSpaceMult: 1e4,
    // Superconducting TSU efficiency multiplier (passive cryo)
    photonicOn: false,
    photonicYear: 2035,
    // Photonic computing availability
    photonicGroundMult: 50,
    // Ground photonic efficiency multiplier
    photonicSpaceMult: 100,
    // Space photonic efficiency multiplier (vacuum optics)
    workloadProbabilistic: 0.15,
    // Fraction of workloads that are sampling-heavy
    // Thermal
    emissivity: 0.85,
    // Radiator surface emissivity
    opTemp: 365,
    // Operating temperature (K)
    radLearn: 50,
    // kg/MW/year improvement for conventional radiators
    // Power
    solarEff: 0.2,
    // Silicon baseline (SpaceX/Starlink approach)
    solarLearn: 8e-3,
    // +0.8%/yr absolute improvement (reaches ~30% by 2038)
    basePower: 300,
    // Platform power before breakthroughs (kW)
    computeFrac: 0.68,
    // Fraction of power to compute
    battDens: 280,
    // Battery density (Wh/kg)
    // Compute
    satLife: 10,
    // Satellite lifetime (years)
    radPen: 0.30,
    // Radiation efficiency penalty (30% of commercial - matches reference)
    aiLearn: 0.20,
    // Annual compute efficiency improvement (20% - matches reference)
    // Launch economics
    launchCost: 1500,
    // Current launch cost ($/kg)
    launchLearn: 0.18,
    // Learning rate per doubling (18% - historical aerospace)
    launchFloor: 15,
    // Physical floor: propellant (~$8/kg) + vehicle amortization (~$4-13/kg) + ground ops (~$2-5/kg)
    prodMult: 2.5,
    // Manufacturing cost multiplier (matches reference, reduces via learning)
    mfgCostMult: 1.0,
    // Manufacturing cost multiplier (slider: 0.5 = optimistic, 1.0 = baseline, 2.0 = conservative)
    maintCost: 0.015,
    // Annual maintenance as fraction of capex (1.5%)
    // Bandwidth
    bandwidth: 20,
    // Total capacity in 2026 (Tbps) - realistic for early space optical networks
    bwGrowth: 0.25,
    // Annual bandwidth growth rate (laser links) - 25% is aggressive but realistic
    gbpsPerTflop: 0.0001,
    // Bandwidth per TFLOP (Gbps) - 0.1 Mbps per TFLOP (batch inference)
    // Market
    orbitalEligibleShare: 0.35,
    // Fraction of demand that is latency-tolerant
    fleetDoublingYears: 2.5,
    // Years for fleet to double (realistic infrastructure buildout pace)
    // Cost of capital
    waccOrbital: 0.1,
    // Orbital WACC (SpaceX track record reduces risk)
    waccGround: 0.08,
    // Ground WACC
    // Ground constraints
    groundPue: 1.3,
    // Power Usage Effectiveness
    energyCost: 0.065,
    // Energy cost ($/kWh) - matches reference
    energyEscal: 0.04,
    // Annual energy cost escalation (4%/yr - matches reference)
    interconnect: 48,
    // Interconnection queue (months) - US grid queues now 4-5+ years
    // Demand
    demand2025: 65,
    // 2025 demand (GW)
    demandGrowth: 0.55,
    // AI boom: 55% annual demand growth (decays over time - matches reference)
    supply2025: 60,
    // 2025 ground supply (GW) - actual global AI-ready DC capacity
    supplyGrowth: 0.08,
    // 8% annual growth (constrained by interconnect, chips, fabs - matches reference)
    // Behind-the-meter generation
    btmShare: 0.15,
    // 15% of new ground capacity is BTM in 2026
    btmShareGrowth: 0.02,
    // Base growth rate per year
    btmDelay: 12,
    // Months to deploy BTM (vs interconnect for grid)
    btmCapexMult: 1.35,
    // 35% higher capex for on-site generation
    btmEnergyCost: 0.04,
    // $/kWh LCOS for solar+storage
    bwCost: 50
    // Bandwidth cost $50k/Gbps/year (laser relay network operating cost)
  };
  return __toCommonJS(bundle_finance_exports);
})();

// ============================================
// BRIDGE: Use bundled model with local params
// ============================================

// Import constants from model
const { YEARS, SLA, SHELLS, STEFAN_BOLTZMANN, defaults } = Model;

// Create mutable params object from defaults
let P = { ...defaults };

// Helper functions that delegate to model
function calcSatellite(year, params = P, shell = 'leo') {
  return Model.calcSatellite(year, params, shell);
}

function calcGround(year, orbitalSupplyGW = 0, params = P) {
  return Model.calcGround(year, orbitalSupplyGW, params);
}

function calcFleet(year, crossoverYear = null, params = P) {
  return Model.calcFleet(year, crossoverYear, params);
}

function getLaunchCost(year, params = P, shell = 'leo') {
  return Model.getLaunchCost(year, params, shell);
}

function getRadiatorMassPerMW(year, powerKw, params = P) {
  return Model.getRadiatorMassPerMW(year, powerKw, params);
}

function getShellRadiationEffects(shell, year, params = P) {
  return Model.getShellRadiationEffects(shell, year, params);
}

function getDemand(year, params = P) {
  return Model.getDemand(year, params);
}

function getGroundSupply(year, params = P) {
  return Model.getGroundSupply(year, params);
}

function getBtmShare(year, params = P) {
  return Model.getBtmShare(year, params);
}

// Scenario parameter generation - wider bands to capture true uncertainty
// Include long-term divergence factors (prodMult, launchFloor, wacc) not just timing
const SCENARIOS = {
  aggressive:   { learnMult: 2.0, techYearOffset: -5, demandMult: 1.5, launchLearnMult: 1.5, prodMult: 0.6, launchFloorMult: 0.5, waccMult: 0.8 },
  baseline:     { learnMult: 1.0, techYearOffset: 0,  demandMult: 1.0, launchLearnMult: 1.0, prodMult: 1.0, launchFloorMult: 1.0, waccMult: 1.0 },
  conservative: { learnMult: 0.4, techYearOffset: 8,  demandMult: 0.5, launchLearnMult: 0.5, prodMult: 1.8, launchFloorMult: 2.0, waccMult: 1.3 }
};

// Mid-timeline architectural uncertainty factor
// Captures: optical vs RF backhaul, GEO vs LEO vs cislunar, nuclear vs solar, regulatory/debris uncertainty
// Returns a multiplier that WIDENS bands during 2035-2045 transition period
function getArchitecturalUncertainty(year, scenario) {
  if (scenario === 'baseline') return 1.0;

  // Uncertainty shape: starts high, narrows, RE-WIDENS mid-timeline, then stabilizes
  // 2026-2030: High initial uncertainty (1.0x)
  // 2030-2035: Narrowing as early tech matures (0.7x)
  // 2035-2045: RE-WIDENS for architectural forks (1.3x peak at 2040)
  // 2045+: Stabilizes as winning architectures emerge (0.8x)

  let factor = 1.0;
  if (year < 2030) {
    factor = 1.0;
  } else if (year < 2035) {
    // Narrowing phase
    factor = 1.0 - 0.3 * (year - 2030) / 5;
  } else if (year < 2040) {
    // Re-widening phase (rising)
    factor = 0.7 + 0.6 * (year - 2035) / 5;
  } else if (year < 2045) {
    // Re-widening phase (falling)
    factor = 1.3 - 0.5 * (year - 2040) / 5;
  } else {
    // Stabilization
    factor = 0.8;
  }

  return factor;
}

function getScenarioParams(scenario) {
  const s = SCENARIOS[scenario] || SCENARIOS.baseline;
  return {
    ...P,
    aiLearn: P.aiLearn * s.learnMult,
    launchLearn: P.launchLearn * s.launchLearnMult,
    thermalYear: P.thermalYear + s.techYearOffset,
    fissionYear: P.fissionYear + s.techYearOffset,
    fusionYear: P.fusionYear + s.techYearOffset,
    demandGrowth: P.demandGrowth * s.demandMult,
    prodMult: P.prodMult * s.prodMult,           // Manufacturing cost uncertainty
    launchFloor: P.launchFloor * s.launchFloorMult, // Launch cost floor uncertainty
    waccOrbital: P.waccOrbital * s.waccMult      // Cost of capital uncertainty
  };
}

function runScenario(scenario) {
  const params = getScenarioParams(scenario);
  const sats = YEARS.map(y => calcSatellite(y, params));

  // Reset fleet tracker for preFleets calculation
  Model.resetFleetTracker();
  const preFleets = YEARS.map(y => calcFleet(y, null, params));
  const preGnds = YEARS.map(y => calcGround(y, 0, params));

  // Debug logging for baseline - LCOC verification table
  if (scenario === 'baseline') {
    console.log('=== LCOC VERIFICATION TABLE ===');
    console.log('Year | Sat LCOC (chart) | Fleet LCOC (effective) | Ground Base | Ground Market');
    [2026, 2030, 2035, 2040, 2050, 2060, 2070].forEach(y => {
      const idx = YEARS.indexOf(y);
      if (idx >= 0) {
        const sat = sats[idx];
        const fleet = preFleets[idx];
        const gnd = preGnds[idx];
        // sat.lcoc is what the chart shows, fleet.lcocEffective accounts for utilization
        console.log(`${y} | $${sat.lcoc.toFixed(2)} | $${fleet.lcocEffective.toFixed(2)} | $${gnd.base.toFixed(2)} | $${gnd.market.toFixed(2)}`);
      }
    });
    console.log('=== ARCHITECTURAL UNCERTAINTY FACTOR ===');
    console.log('Year | Factor | Effect');
    [2026, 2030, 2035, 2040, 2045, 2050, 2060, 2070].forEach(y => {
      const factor = getArchitecturalUncertainty(y, 'aggressive');
      let effect = factor > 1.0 ? 'WIDENING' : factor < 1.0 ? 'narrowing' : 'baseline';
      console.log(`${y} | ${factor.toFixed(2)}x | ${effect}`);
    });
  }

  // Crossover: when orbital production LCOC beats ground LCOC
  // Use sat.lcoc (production cost) not lcocEffective (which depends on sellability)
  // This gives a stable crossover point that matches what the chart shows
  const crossIdx = sats.findIndex((sat, i) => sat.lcoc < preGnds[i].base);
  const crossoverYear = crossIdx >= 0 ? YEARS[crossIdx] : null;

  // Reset fleet tracker for final fleets calculation (with crossover)
  Model.resetFleetTracker();
  const fleets = YEARS.map(y => calcFleet(y, crossoverYear, params));
  const gnds = YEARS.map((y, i) => calcGround(y, fleets[i].totalPowerTw * 1000, params));
  
  return { sats, fleets, gnds, crossoverYear };
}

function formatPrice(p) {
  if (p >= 100) return p.toFixed(0);
  if (p >= 10) return p.toFixed(1);
  if (p >= 1) return p.toFixed(2);
  return p.toFixed(3);
}

// Helper to format tokens per year (SI prefixes)
function formatTokens(t) {
  if (t >= 1e18) return (t / 1e18).toFixed(1) + ' Etok';
  if (t >= 1e15) return (t / 1e15).toFixed(1) + ' Ptok';
  if (t >= 1e12) return (t / 1e12).toFixed(1) + ' Ttok';
  if (t >= 1e9) return (t / 1e9).toFixed(1) + ' Gtok';
  if (t >= 1e6) return (t / 1e6).toFixed(1) + ' Mtok';
  return t.toFixed(0);
}

let fleetResults = [];

// CHARTS
// ============================================

Chart.defaults.color = '#666666';
Chart.defaults.borderColor = '#d0d0d0';
Chart.defaults.font.family = 'Inter';

let charts = {};

function initCharts() {
  const opts = (yLabel, log = false) => ({
    responsive: true, maintainAspectRatio: false,
    plugins: { legend: { display: false } },
    scales: { y: { type: log ? 'logarithmic' : 'linear', title: { display: true, text: yLabel } } }
  });
  const stackOpts = (yLabel) => ({
    responsive: true, maintainAspectRatio: false,
    plugins: { legend: { display: false } },
    scales: { x: { stacked: true }, y: { stacked: true, title: { display: true, text: yLabel } } }
  });
  
  // Core - LCOC with uncertainty bands
  charts.lcoc = new Chart(document.getElementById('c-lcoc'), {
    type: 'line', data: { labels: YEARS, datasets: [
      // Aggressive bound (upper for uncertainty)
      { data: [], borderColor: 'transparent', backgroundColor: 'rgba(0,102,204,0.2)', fill: '+1', tension: 0.3, pointRadius: 0 },
      // Baseline orbital
      { data: [], borderColor: '#0066cc', borderWidth: 2, tension: 0.3, pointRadius: 0 },
      // Conservative bound (lower)
      { data: [], borderColor: 'transparent', backgroundColor: 'rgba(0,102,204,0.2)', fill: '-1', tension: 0.3, pointRadius: 0 },
      // Ground market
      { data: [], borderColor: '#cc3333', borderWidth: 2, tension: 0.3, pointRadius: 0 }
    ]}, options: opts('$/GPU-hr', true)
  });
  
  
  // Fleet by shell - stacked area chart
  charts.fleet = new Chart(document.getElementById('c-fleet'), {
    type: 'line', data: { labels: YEARS, datasets: [
      { data: [], borderColor: '#0066cc', backgroundColor: 'rgba(0,102,204,0.5)', fill: true, tension: 0.3 },
      { data: [], borderColor: '#0066cc', backgroundColor: 'rgba(0,102,204,0.5)', fill: true, tension: 0.3 },
      { data: [], borderColor: '#cc8800', backgroundColor: 'rgba(204,136,0,0.5)', fill: true, tension: 0.3 },
      { data: [], borderColor: '#6633cc', backgroundColor: 'rgba(102,51,204,0.5)', fill: true, tension: 0.3 }
    ]}, options: {
      ...opts('TW', true),
      scales: {
        x: { stacked: true },
        y: { stacked: true, beginAtZero: true }
      }
    }
  });
  
  charts.carbon = new Chart(document.getElementById('c-carbon'), {
    type: 'line', data: { labels: YEARS, datasets: [
      { data: [], borderColor: '#0066cc', tension: 0.3 },
      { data: [], borderColor: '#cc3333', tension: 0.3 }
    ]}, options: opts('gCO₂/TFLOP-hr')
  });
  
  // Market
  charts.supplyDemand = new Chart(document.getElementById('c-supplyDemand'), {
    type: 'line', data: { labels: YEARS, datasets: [
      { data: [], borderColor: '#cc3333', tension: 0.3, borderWidth: 2 },
      { data: [], borderColor: '#7a7a88', borderDash: [4,4], tension: 0.3 },
      { data: [], borderColor: '#0066cc', tension: 0.3, borderWidth: 2 }
    ]}, options: opts('GW', true)
  });
  
  charts.scarcity = new Chart(document.getElementById('c-scarcity'), {
    type: 'line', data: { labels: YEARS, datasets: [
      { data: [], borderColor: '#cc3333', backgroundColor: 'rgba(204,51,51,0.1)', fill: true, tension: 0.3 }
    ]}, options: opts('×')
  });
  
  charts.efficiency = new Chart(document.getElementById('c-efficiency'), {
    type: 'line', data: { labels: YEARS, datasets: [
      { data: [], borderColor: '#0066cc', tension: 0.3 },
      { data: [], borderColor: '#cc3333', tension: 0.3 }
    ]}, options: opts('GFLOPS/W', true)
  });
  
  // Constraints - Shell utilization for all 4 shells
  charts.shellUtil = new Chart(document.getElementById('c-shellUtil'), {
    type: 'line', data: { labels: YEARS, datasets: [
      { data: [], borderColor: '#0066cc', tension: 0.3 },
      { data: [], borderColor: '#0066cc', tension: 0.3 },
      { data: [], borderColor: '#cc8800', tension: 0.3 },
      { data: [], borderColor: '#6633cc', tension: 0.3 }
    ]}, options: opts('%')
  });
  
  charts.bandwidth = new Chart(document.getElementById('c-bandwidth'), {
    type: 'line', data: { labels: YEARS, datasets: [
      { data: [], borderColor: '#0066cc', backgroundColor: 'rgba(0,102,204,0.1)', fill: true, tension: 0.3 }
    ]}, options: opts('Tbps', true)
  });
  
  charts.bwUtil = new Chart(document.getElementById('c-bwUtil'), {
    type: 'line', data: { labels: YEARS, datasets: [
      { data: [], borderColor: '#cc6600', backgroundColor: 'rgba(204,102,0,0.1)', fill: true, tension: 0.3 }
    ]}, options: opts('%')
  });
  
  // Stranded capex penalty (LCOC multiplier from underutilization)
  charts.stranded = new Chart(document.getElementById('c-stranded'), {
    type: 'line', data: { labels: YEARS, datasets: [
      { data: [], borderColor: '#cc3333', backgroundColor: 'rgba(204,51,51,0.1)', fill: true, tension: 0.3 }
    ]}, options: opts('×')
  });
  
  charts.thermal = new Chart(document.getElementById('c-thermal'), {
    type: 'line', data: { labels: YEARS, datasets: [
      { data: [], borderColor: '#cc3333', backgroundColor: 'rgba(204,51,51,0.1)', fill: true, tension: 0.1 }
    ]}, options: opts('kg/kW')
  });
  
  charts.erol = new Chart(document.getElementById('c-erol'), {
    type: 'line', data: { labels: YEARS, datasets: [
      { data: [], borderColor: '#cc8800', backgroundColor: 'rgba(204,136,0,0.1)', fill: true, tension: 0.3 }
    ]}, options: opts('×')
  });

  // Power per TFLOP - shows efficiency gains from thermo/photonic
  charts.powerPerTflop = new Chart(document.getElementById('c-powerPerTflop'), {
    type: 'line', data: { labels: YEARS, datasets: [
      { data: [], borderColor: '#0066cc', tension: 0.3, borderWidth: 2 },  // Orbital
      { data: [], borderColor: '#cc3333', tension: 0.3, borderWidth: 2 }   // Ground
    ]}, options: opts('kW/TFLOP', true)
  });

  charts.bottleneck = new Chart(document.getElementById('c-bottleneck'), {
    type: 'bar', data: { labels: YEARS, datasets: [
      { data: [], backgroundColor: 'rgba(204,102,0,0.7)' },  // Thermal - orange
      { data: [], backgroundColor: 'rgba(204,170,0,0.7)' },  // Power - gold
      { data: [], backgroundColor: 'rgba(0,102,204,0.7)' },  // Bandwidth - blue
      { data: [], backgroundColor: 'rgba(102,51,204,0.7)' }, // Slots - purple
      { data: [], backgroundColor: 'rgba(0,153,102,0.7)' },  // Demand - green
      { data: [], backgroundColor: 'rgba(153,51,51,0.7)' }   // Launch capacity - red
    ]}, options: stackOpts('Constraint')
  });
  
  // Physics - all 4 shells
  charts.power = new Chart(document.getElementById('c-power'), {
    type: 'line', data: { labels: YEARS, datasets: [
      { data: [], borderColor: '#1a8a6a', tension: 0.1, borderWidth: 2 }, // LEO
      { data: [], borderColor: '#0066cc', tension: 0.1, borderWidth: 2 }, // MEO
      { data: [], borderColor: '#cc8800', tension: 0.1, borderWidth: 2 }, // GEO
      { data: [], borderColor: '#6633cc', tension: 0.1, borderWidth: 2 }  // Cislunar
    ]}, options: opts('MW', true)
  });
  
  charts.specPower = new Chart(document.getElementById('c-specPower'), {
    type: 'line', data: { labels: YEARS, datasets: [
      { data: [], borderColor: '#0066cc', backgroundColor: 'rgba(0,102,204,0.1)', fill: true, tension: 0.3 }
    ]}, options: opts('W/kg', true)
  });
  
  charts.mass = new Chart(document.getElementById('c-mass'), {
    type: 'bar', data: { labels: YEARS, datasets: [
      { data: [], backgroundColor: '#cc8800' },
      { data: [], backgroundColor: '#6633cc' },
      { data: [], backgroundColor: '#0066cc' },
      { data: [], backgroundColor: '#cc3333' },
      { data: [], backgroundColor: '#7a7a88' }
    ]}, options: stackOpts('kg')
  });
  
  charts.powerBudget = new Chart(document.getElementById('c-powerBudget'), {
    type: 'bar', data: { labels: YEARS, datasets: [
      { data: [], backgroundColor: 'rgba(0,102,204,0.7)' },     // Compute - teal
      { data: [], backgroundColor: 'rgba(204,102,0,0.7)' },    // Thermal - orange
      { data: [], backgroundColor: 'rgba(122,122,136,0.7)' }    // Housekeeping - gray
    ]}, options: stackOpts('%')
  });
  
  charts.launch = new Chart(document.getElementById('c-launch'), {
    type: 'line', data: { labels: YEARS, datasets: [
      { data: [], borderColor: '#cc6600', tension: 0.3 }
    ]}, options: opts('$/kg', true)
  });
  
  charts.dataRate = new Chart(document.getElementById('c-dataRate'), {
    type: 'line', data: { labels: YEARS, datasets: [
      { data: [], borderColor: '#0066cc', backgroundColor: 'rgba(0,102,204,0.1)', fill: true, tension: 0.3 }
    ]}, options: opts('Gbps', true)
  });
  
  // Reliability overhead by shell (SEU penalty)
  charts.reliability = new Chart(document.getElementById('c-reliability'), {
    type: 'line', data: { labels: YEARS, datasets: [
      { data: [], borderColor: '#0066cc', tension: 0.3, borderWidth: 2 }, // LEO
      { data: [], borderColor: '#cc8800', tension: 0.3, borderWidth: 2 }, // MEO
      { data: [], borderColor: '#0066cc', tension: 0.3, borderWidth: 2 }, // GEO
      { data: [], borderColor: '#6633cc', tension: 0.3, borderWidth: 2 }  // Cislunar
    ]}, options: opts('%')
  });
  
  // Futures - with uncertainty bands
  charts.lcocScenarios = new Chart(document.getElementById('c-lcocScenarios'), {
    type: 'line', data: { labels: YEARS, datasets: [
      // Aggressive bound (upper)
      { data: [], borderColor: 'transparent', backgroundColor: 'rgba(0,102,204,0.2)', fill: '+1', tension: 0.3, pointRadius: 0 },
      // Baseline orbital
      { data: [], borderColor: '#0066cc', borderWidth: 2, tension: 0.3, pointRadius: 0 },
      // Conservative bound (lower)
      { data: [], borderColor: 'transparent', backgroundColor: 'rgba(0,102,204,0.2)', fill: '-1', tension: 0.3, pointRadius: 0 },
      // Ground market
      { data: [], borderColor: '#7a7a88', borderDash: [4,4], borderWidth: 2, tension: 0.3, pointRadius: 0 }
    ]}, options: opts('$/GPU-hr', true)
  });
  
  charts.carbonScenarios = new Chart(document.getElementById('c-carbonScenarios'), {
    type: 'line', data: { labels: YEARS, datasets: [
      // Aggressive bound
      { data: [], borderColor: 'transparent', backgroundColor: 'rgba(0,102,204,0.2)', fill: '+1', tension: 0.3, pointRadius: 0 },
      // Baseline
      { data: [], borderColor: '#0066cc', borderWidth: 2, tension: 0.3, pointRadius: 0 },
      // Conservative bound
      { data: [], borderColor: 'transparent', backgroundColor: 'rgba(0,102,204,0.2)', fill: '-1', tension: 0.3, pointRadius: 0 }
    ]}, options: opts('gCO₂/TFLOP-hr')
  });
  
  charts.effScenarios = new Chart(document.getElementById('c-effScenarios'), {
    type: 'line', data: { labels: YEARS, datasets: [
      // Aggressive bound
      { data: [], borderColor: 'transparent', backgroundColor: 'rgba(0,102,204,0.2)', fill: '+1', tension: 0.3, pointRadius: 0 },
      // Baseline
      { data: [], borderColor: '#0066cc', borderWidth: 2, tension: 0.3, pointRadius: 0 },
      // Conservative bound
      { data: [], borderColor: 'transparent', backgroundColor: 'rgba(0,102,204,0.2)', fill: '-1', tension: 0.3, pointRadius: 0 }
    ]}, options: opts('GFLOPS/W', true)
  });
}

function update() {
  // DEBUG: Log key params at update time
  console.log('=== UPDATE CALLED ===');
  console.log('Key slider params:', {
    radLearn: P.radLearn,
    solarEff: P.solarEff,
    prodMult: P.prodMult,
    maintCost: P.maintCost,
    bwCost: P.bwCost
  });
  console.log('Thermo:', { on: P.thermoOn, mult: P.thermoSpaceMult, workloadProb: P.workloadProbabilistic });
  console.log('Fusion:', { on: P.fusionOn, year: P.fusionYear });

  // Run all scenarios
  const agg = runScenario('aggressive');
  const base = runScenario('baseline');
  const cons = runScenario('conservative');

  // Use baseline for main display
  const sats = base.sats;
  const gnds = base.gnds;
  fleetResults = base.fleets;
  const crossoverYear = base.crossoverYear;

  const i30 = 4, i35 = 9, i40 = 14, i50 = 24;

  // DEBUG: Log key results
  console.log('2035 Results:', {
    satTflops: sats[i35].tflops,
    satGflopsW: sats[i35].gflopsW,
    satPowerKw: sats[i35].powerKw,
    fleetDelivered: fleetResults[i35].deliveredTokensPerYear,
    fleetLcoc: fleetResults[i35].lcocEffective,
    leoPlatforms: fleetResults[i35].leoPlatforms,
    sellableUtil: fleetResults[i35].sellableUtil
  });
  
  // Header badges
  document.getElementById('badge-crossover').textContent = crossoverYear || 'Never';
  document.getElementById('badge-fleet50').textContent = fleetResults[i50].totalPowerTw.toFixed(1) + ' TW';
  
  // Hero LCOC display
  document.getElementById('hero-crossover').textContent = crossoverYear || 'Never';
  document.getElementById('hero-orb35').textContent = '$' + formatPrice(fleetResults[i35].lcocEffective);
  document.getElementById('hero-gnd35').textContent = '$' + formatPrice(gnds[i35].base);  // LCOC = cost basis
  // Core KPIs - just 2035 and 2050
  document.getElementById('kpi-orb35').textContent = '$' + formatPrice(fleetResults[i35].lcocEffective);
  document.getElementById('kpi-gnd35').textContent = '$' + formatPrice(gnds[i35].base);  // LCOC = cost basis
  document.getElementById('kpi-orb50').textContent = '$' + formatPrice(fleetResults[i50].lcocEffective);
  document.getElementById('kpi-gnd50').textContent = '$' + formatPrice(gnds[i50].base);  // LCOC = cost basis
  document.getElementById('kpi-tokens35').textContent = formatTokens(fleetResults[i35].deliveredTokensPerYear);
  document.getElementById('kpi-tokens50').textContent = formatTokens(fleetResults[i50].deliveredTokensPerYear);

  // Derived values
  const radPower = P.emissivity * STEFAN_BOLTZMANN * Math.pow(P.opTemp, 4);
  document.getElementById('d-radPower').textContent = radPower.toFixed(0);
  document.getElementById('d-radMass').textContent = sats[i30].radMassPerMW.toFixed(0);
  document.getElementById('d-launchLeo').textContent = getLaunchCost(2030, P, 'leo').toFixed(0);
  document.getElementById('d-launchGeo').textContent = getLaunchCost(2030, P, 'geo').toFixed(0);
  document.getElementById('d-satPower').textContent = sats[i30].powerKw.toFixed(0);
  document.getElementById('d-satMass').textContent = sats[i30].dryMass.toFixed(0);
  document.getElementById('d-demand35').textContent = gnds[i35].demand.toFixed(0);
  document.getElementById('d-supply35').textContent = gnds[i35].groundSupply.toFixed(0);
  
  // Market KPIs
  document.getElementById('kpi-peakPrem').textContent = Math.max(...gnds.map(g => g.premium)).toFixed(1) + '×';
  document.getElementById('kpi-prem35').textContent = gnds[i35].premium.toFixed(1) + '×';
  document.getElementById('kpi-unmet35').textContent = (gnds[i35].unmetRatio * 100).toFixed(0) + '%';
  
  // Constraints KPIs
  document.getElementById('kpi-bwUtil').textContent = (fleetResults[i35].bwUtil * 100).toFixed(0) + '%';
  const totalPlat35 = fleetResults[i35].leoPlatforms + fleetResults[i35].meoPlatforms + 
                      fleetResults[i35].geoPlatforms + fleetResults[i35].cisPlatforms;
  const totalPlat50 = fleetResults[i50].leoPlatforms + fleetResults[i50].meoPlatforms + 
                      fleetResults[i50].geoPlatforms + fleetResults[i50].cisPlatforms;
  document.getElementById('kpi-plat35').textContent = (totalPlat35 / 1000).toFixed(0) + 'k';
  document.getElementById('kpi-plat50').textContent = (totalPlat50 / 1000).toFixed(0) + 'k';
  
  // Physics KPIs
  document.getElementById('kpi-leo').textContent = (sats[i35].powerKw / 1000).toFixed(1) + ' MW';
  document.getElementById('kpi-cis').textContent = (fleetResults[i35].cislunarPowerKw / 1000).toFixed(0) + ' MW';
  document.getElementById('kpi-mass').textContent = sats[i35].dryMass.toFixed(0) + ' kg';
  
  // Futures KPIs
  document.getElementById('kpi-crossAgg').textContent = agg.crossoverYear || 'Never';
  document.getElementById('kpi-crossBase').textContent = base.crossoverYear || 'Never';
  document.getElementById('kpi-crossCons').textContent = cons.crossoverYear || 'Never';
  
  // Toggle effects - thermal is always on
  document.getElementById('eff-thermal').className = 'toggle-effect active';
  document.getElementById('eff-fission').className = 'toggle-effect' + (P.fissionOn ? ' active' : '');
  document.getElementById('eff-smr').className = 'toggle-effect' + (P.smrOn ? ' active' : '');
  document.getElementById('eff-fusion').className = 'toggle-effect' + (P.fusionOn ? ' active' : '');
  document.getElementById('eff-thermo').className = 'toggle-effect' + (P.thermoOn ? ' active' : '');
  
  // Core charts - LCOC with uncertainty
  // Use sat.lcoc (production cost) for cleaner curves that match crossover detection
  // Apply mid-timeline architectural uncertainty (bands re-widen 2035-2045)
  // Clamp LCOC to displayable range for log chart (max $500/GPU-hr, min $0.001)
  const clampLcoc = (val) => {
    if (!isFinite(val) || val <= 0) return 500;  // Infinity/NaN/0 → cap
    return Math.min(500, Math.max(0.001, val));
  };
  charts.lcoc.data.datasets[0].data = agg.sats.map((sat, i) => {
    const year = YEARS[i];
    const baseLcoc = clampLcoc(base.sats[i].lcoc);
    const aggLcoc = clampLcoc(sat.lcoc);
    const factor = getArchitecturalUncertainty(year, 'aggressive');
    return baseLcoc + (aggLcoc - baseLcoc) * factor;
  });
  charts.lcoc.data.datasets[1].data = base.sats.map(s => clampLcoc(s.lcoc));  // Production cost
  charts.lcoc.data.datasets[2].data = cons.sats.map((sat, i) => {
    const year = YEARS[i];
    const baseLcoc = clampLcoc(base.sats[i].lcoc);
    const consLcoc = clampLcoc(sat.lcoc);
    const factor = getArchitecturalUncertainty(year, 'conservative');
    return baseLcoc + (consLcoc - baseLcoc) * factor;
  });
  charts.lcoc.data.datasets[3].data = gnds.map(g => clampLcoc(g.base));  // Ground production cost

  charts.lcoc.update();
  
  // Fleet by shell
  charts.fleet.data.datasets[0].data = fleetResults.map(f => f.leoPowerTw);
  charts.fleet.data.datasets[1].data = fleetResults.map(f => f.meoPowerTw);
  charts.fleet.data.datasets[2].data = fleetResults.map(f => f.geoPowerTw);
  charts.fleet.data.datasets[3].data = fleetResults.map(f => f.cisPowerTw);
  charts.fleet.update();
  
  charts.carbon.data.datasets[0].data = sats.map(s => s.carbonPerTflop);
  charts.carbon.data.datasets[1].data = gnds.map(g => g.carbonPerTflop);
  charts.carbon.update();
  
  // Market charts
  charts.supplyDemand.data.datasets[0].data = gnds.map(g => g.demand);
  charts.supplyDemand.data.datasets[1].data = gnds.map(g => g.groundSupply);
  charts.supplyDemand.data.datasets[2].data = gnds.map(g => g.totalSupply);
  charts.supplyDemand.update();
  
  charts.scarcity.data.datasets[0].data = gnds.map(g => g.premium);
  charts.scarcity.update();
  
  charts.efficiency.data.datasets[0].data = sats.map(s => s.gflopsW);
  charts.efficiency.data.datasets[1].data = gnds.map(g => g.gflopsW);
  charts.efficiency.update();
  
  // Constraints charts - all 4 shells
  charts.shellUtil.data.datasets[0].data = fleetResults.map(f => f.leoUtil * 100);
  charts.shellUtil.data.datasets[1].data = fleetResults.map(f => f.meoUtil * 100);
  charts.shellUtil.data.datasets[2].data = fleetResults.map(f => f.geoUtil * 100);
  charts.shellUtil.data.datasets[3].data = fleetResults.map(f => f.cisUtil * 100);
  charts.shellUtil.update();
  
  charts.bwUtil.data.datasets[0].data = fleetResults.map(f => f.bwUtil * 100);
  charts.bwUtil.update();
  
  charts.bandwidth.data.datasets[0].data = fleetResults.map(f => f.bwAvailGbps / 1000); // Convert to Tbps for display
  charts.bandwidth.update();
  
  // Stranded capex penalty (1/sellableUtil - shows LCOC inflation from underutilization)
  charts.stranded.data.datasets[0].data = fleetResults.map(f => 1 / Math.max(0.01, f.sellableUtil || 1));
  charts.stranded.update();
  
  // Thermal: show radiator specific mass (kg/kW) - thermal breakthrough makes this 50× lower
  charts.thermal.data.datasets[0].data = sats.map(s => getRadiatorMassPerMW(s.year, s.powerKw) / 1000);
  charts.thermal.update();
  
  // Bottleneck: thermal, power, mass are all satellite design constraints
  charts.bottleneck.data.datasets[0].data = fleetResults.map(f => f.bottleneck === 'thermal' ? 1 : 0);
  charts.bottleneck.data.datasets[1].data = fleetResults.map(f => (f.bottleneck === 'power' || f.bottleneck === 'mass') ? 1 : 0); // Combine power/mass
  charts.bottleneck.data.datasets[2].data = fleetResults.map(f => f.bottleneck === 'bandwidth' ? 1 : 0);
  charts.bottleneck.data.datasets[3].data = fleetResults.map(f => f.bottleneck === 'slots' ? 1 : 0);
  charts.bottleneck.data.datasets[4].data = fleetResults.map(f => f.bottleneck === 'demand' ? 1 : 0);
  charts.bottleneck.data.datasets[5].data = fleetResults.map(f => f.bottleneck === 'launch_capacity' ? 1 : 0);
  charts.bottleneck.update();
  
  // Physics charts - all 4 shells
  charts.power.data.datasets[0].data = sats.map(s => s.powerKw / 1000); // LEO
  charts.power.data.datasets[1].data = sats.map(s => s.powerKw * 0.8 / 1000); // MEO (80% of LEO)
  charts.power.data.datasets[2].data = sats.map((s, i) => {
    const year = 2026 + i;
    const hasFission = P.fissionOn && year >= P.fissionYear;
    const hasThermal = P.thermalOn && year >= P.thermalYear;
    const mult = hasFission ? 20 : hasThermal ? 10 : 5;
    return s.powerKw * mult / 1000; // GEO
  });
  charts.power.data.datasets[3].data = fleetResults.map(f => f.cislunarPowerKw / 1000); // Cislunar
  charts.power.update();
  
  charts.specPower.data.datasets[0].data = sats.map(s => s.specPower);
  charts.specPower.update();
  
  charts.mass.data.datasets[0].data = sats.map(s => s.mass.power);
  charts.mass.data.datasets[1].data = sats.map(s => s.mass.batt);
  charts.mass.data.datasets[2].data = sats.map(s => s.mass.comp);
  charts.mass.data.datasets[3].data = sats.map(s => s.mass.rad);
  charts.mass.data.datasets[4].data = sats.map(s => s.mass.struct);
  charts.mass.update();
  
  // Power budget: compute (68%), thermal management (~22%), housekeeping (~10%)
  // Power budget: compute, thermal management, housekeeping
  const compPct = P.computeFrac * 100;
  const thermalPct = (1 - P.computeFrac) * 0.7 * 100; // ~70% of non-compute goes to thermal
  const housePct = 100 - compPct - thermalPct;
  charts.powerBudget.data.datasets[0].data = YEARS.map(() => compPct);
  charts.powerBudget.data.datasets[1].data = YEARS.map(() => thermalPct);
  charts.powerBudget.data.datasets[2].data = YEARS.map(() => housePct);
  charts.powerBudget.update();
  
  charts.launch.data.datasets[0].data = YEARS.map(y => getLaunchCost(y));
  charts.launch.update();
  
  charts.dataRate.data.datasets[0].data = sats.map(s => s.dataRateGbps);
  charts.dataRate.update();
  
  // Reliability overhead by shell (SEU penalty as % overhead)
  charts.reliability.data.datasets[0].data = YEARS.map(y => (getShellRadiationEffects('leo', y).seuPenalty - 1) * 100);
  charts.reliability.data.datasets[1].data = YEARS.map(y => (getShellRadiationEffects('meo', y).seuPenalty - 1) * 100);
  charts.reliability.data.datasets[2].data = YEARS.map(y => (getShellRadiationEffects('geo', y).seuPenalty - 1) * 100);
  charts.reliability.data.datasets[3].data = YEARS.map(y => (getShellRadiationEffects('cislunar', y).seuPenalty - 1) * 100);
  charts.reliability.update();
  
  charts.erol.data.datasets[0].data = sats.map(s => s.erol);
  charts.erol.update();

  // Power per TFLOP - inverse of efficiency (kW needed per TFLOP)
  // gflopsW is GFLOPS/W, so W/GFLOPS = 1/gflopsW, and kW/TFLOP = 1/gflopsW (since 1 TFLOP = 1000 GFLOPS, 1 kW = 1000 W)
  charts.powerPerTflop.data.datasets[0].data = sats.map(s => 1 / s.gflopsW);  // Orbital
  charts.powerPerTflop.data.datasets[1].data = gnds.map(g => 1 / g.gflopsW);  // Ground
  charts.powerPerTflop.update();

  // Futures charts - use sat.lcoc (production cost) for consistency with main LCOC chart
  // Apply same clamping as main LCOC chart
  charts.lcocScenarios.data.datasets[0].data = agg.sats.map((sat, i) => {
    const year = YEARS[i];
    const baseLcoc = clampLcoc(base.sats[i].lcoc);
    const aggLcoc = clampLcoc(sat.lcoc);
    const factor = getArchitecturalUncertainty(year, 'aggressive');
    return baseLcoc + (aggLcoc - baseLcoc) * factor;
  });
  charts.lcocScenarios.data.datasets[1].data = base.sats.map(s => clampLcoc(s.lcoc));
  charts.lcocScenarios.data.datasets[2].data = cons.sats.map((sat, i) => {
    const year = YEARS[i];
    const baseLcoc = clampLcoc(base.sats[i].lcoc);
    const consLcoc = clampLcoc(sat.lcoc);
    const factor = getArchitecturalUncertainty(year, 'conservative');
    return baseLcoc + (consLcoc - baseLcoc) * factor;
  });
  charts.lcocScenarios.data.datasets[3].data = base.gnds.map(g => clampLcoc(g.base));  // Ground production cost
  charts.lcocScenarios.update();

  charts.carbonScenarios.data.datasets[0].data = agg.sats.map((s, i) => {
    const year = YEARS[i];
    const baseCarbon = base.sats[i].carbonPerTflop;
    const factor = getArchitecturalUncertainty(year, 'aggressive');
    return baseCarbon + (s.carbonPerTflop - baseCarbon) * factor;
  });
  charts.carbonScenarios.data.datasets[1].data = base.sats.map(s => s.carbonPerTflop);
  charts.carbonScenarios.data.datasets[2].data = cons.sats.map((s, i) => {
    const year = YEARS[i];
    const baseCarbon = base.sats[i].carbonPerTflop;
    const factor = getArchitecturalUncertainty(year, 'conservative');
    return baseCarbon + (s.carbonPerTflop - baseCarbon) * factor;
  });
  charts.carbonScenarios.update();

  charts.effScenarios.data.datasets[0].data = agg.sats.map((s, i) => {
    const year = YEARS[i];
    const baseEff = base.sats[i].gflopsW;
    const factor = getArchitecturalUncertainty(year, 'aggressive');
    return baseEff + (s.gflopsW - baseEff) * factor;
  });
  charts.effScenarios.data.datasets[1].data = base.sats.map(s => s.gflopsW);
  charts.effScenarios.data.datasets[2].data = cons.sats.map((s, i) => {
    const year = YEARS[i];
    const baseEff = base.sats[i].gflopsW;
    const factor = getArchitecturalUncertainty(year, 'conservative');
    return baseEff + (s.gflopsW - baseEff) * factor;
  });
  charts.effScenarios.update();
}

// ============================================
// EVENTS
// ============================================

document.addEventListener('DOMContentLoaded', () => {
  initCharts();
  
  // Thermal is always on - just handle the year slider
  P.thermalOn = true;
  const thermalYearSlider = document.getElementById('thermalYear');
  const thermalYearVal = document.getElementById('v-thermalYear');
  if (thermalYearSlider) {
    thermalYearSlider.addEventListener('input', () => {
      P.thermalYear = parseInt(thermalYearSlider.value);
      if (thermalYearVal) thermalYearVal.textContent = P.thermalYear;
      update();
    });
  }

  // Starship is always on - just handle the year slider
  P.starshipOn = true;
  const starshipYearSlider = document.getElementById('starshipYear');
  const starshipYearVal = document.getElementById('v-starshipYear');
  if (starshipYearSlider) {
    starshipYearSlider.addEventListener('input', () => {
      P.starshipYear = parseInt(starshipYearSlider.value);
      if (starshipYearVal) starshipYearVal.textContent = P.starshipYear;
      update();
    });
  }

  // Other breakthroughs have toggles
  ['fission', 'fusion', 'smr', 'thermo', 'photonic'].forEach(tech => {
    const toggle = document.getElementById('tog-' + tech);
    const yearInput = document.getElementById('year-' + tech);
    if (!toggle) return;

    P[tech + 'On'] = toggle.checked;
    if (yearInput) yearInput.disabled = !toggle.checked;

    // Special handling for thermo sliders visibility
    if (tech === 'thermo') {
      const thermoSliders = document.getElementById('thermo-sliders');
      if (thermoSliders) thermoSliders.style.display = toggle.checked ? 'block' : 'none';
    }
    // Special handling for photonic sliders visibility
    if (tech === 'photonic') {
      const photonicSliders = document.getElementById('photonic-sliders');
      if (photonicSliders) photonicSliders.style.display = toggle.checked ? 'block' : 'none';
    }

    toggle.addEventListener('change', () => {
      P[tech + 'On'] = toggle.checked;
      if (yearInput) yearInput.disabled = !toggle.checked;

      // Special handling for thermo sliders visibility
      if (tech === 'thermo') {
        const thermoSliders = document.getElementById('thermo-sliders');
        if (thermoSliders) thermoSliders.style.display = toggle.checked ? 'block' : 'none';
      }
      // Special handling for photonic sliders visibility
      if (tech === 'photonic') {
        const photonicSliders = document.getElementById('photonic-sliders');
        if (photonicSliders) photonicSliders.style.display = toggle.checked ? 'block' : 'none';
      }

      update();
    });
    if (yearInput) {
      yearInput.addEventListener('change', () => {
        P[tech + 'Year'] = parseInt(yearInput.value);
        update();
      });
    }
  });
  
  const sliders = {
    emissivity: { p: 'emissivity', s: 0.01, f: v => v.toFixed(2) },
    opTemp: { p: 'opTemp', s: 1, f: v => v },
    radLearn: { p: 'radLearn', s: 1, f: v => v },
    solarEff: { p: 'solarEff', s: 0.01, f: v => Math.round(v * 100) },
    solarLearn: { p: 'solarLearn', s: 0.001, f: v => (v * 1000).toFixed(1) },
    basePower: { p: 'basePower', s: 1, f: v => v },
    computeFrac: { p: 'computeFrac', s: 0.01, f: v => Math.round(v * 100) },
    battDens: { p: 'battDens', s: 1, f: v => v },
    satLife: { p: 'satLife', s: 1, f: v => v },
    radPen: { p: 'radPen', s: 0.01, f: v => Math.round(v * 100) },
    aiLearn: { p: 'aiLearn', s: 0.01, f: v => Math.round(v * 100) },
    launchCost: { p: 'launchCost', s: 1, f: v => v },
    launchLearn: { p: 'launchLearn', s: 0.01, f: v => Math.round(v * 100) },
    launchFloor: { p: 'launchFloor', s: 1, f: v => v },
    prodMult: { p: 'prodMult', s: 0.1, f: v => v.toFixed(1) },
    mfgCostMult: { p: 'mfgCostMult', s: 0.1, f: v => v.toFixed(1) },
    maintCost: { p: 'maintCost', s: 0.01, f: v => Math.round(v * 100) },
    waccOrbital: { p: 'waccOrbital', s: 0.01, f: v => Math.round(v * 100) },
    waccGround: { p: 'waccGround', s: 0.01, f: v => Math.round(v * 100) },
    bandwidth: { p: 'bandwidth', s: 1, f: v => v },
    bwGrowth: { p: 'bwGrowth', s: 0.01, f: v => Math.round(v * 100) },
    bwCost: { p: 'bwCost', s: 1, f: v => v },
    gbpsPerTflop: { p: 'gbpsPerTflop', s: 1e-6, f: v => Math.round(v * 1e6) }, // Display as kbps (1 kbps = 1e-6 Gbps)
    groundPue: { p: 'groundPue', s: 0.01, f: v => v.toFixed(2) },
    energyCost: { p: 'energyCost', s: 0.001, f: v => v.toFixed(3) },
    energyEscal: { p: 'energyEscal', s: 0.01, f: v => Math.round(v * 100) },
    interconnect: { p: 'interconnect', s: 1, f: v => v },
    demand2025: { p: 'demand2025', s: 1, f: v => v },
    demandGrowth: { p: 'demandGrowth', s: 0.01, f: v => Math.round(v * 100) },
    orbitalEligibleShare: { p: 'orbitalEligibleShare', s: 0.01, f: v => Math.round(v * 100) },
    supply2025: { p: 'supply2025', s: 1, f: v => v },
    supplyGrowth: { p: 'supplyGrowth', s: 0.01, f: v => Math.round(v * 100) },
    workloadProbabilistic: { p: 'workloadProbabilistic', s: 0.01, f: v => Math.round(v * 100) },
    btmShare: { p: 'btmShare', s: 0.01, f: v => Math.round(v * 100) },
    btmDelay: { p: 'btmDelay', s: 1, f: v => v },
    btmCapexMult: { p: 'btmCapexMult', s: 0.01, f: v => v.toFixed(2) },
    btmEnergyCost: { p: 'btmEnergyCost', s: 0.001, f: v => v.toFixed(3) }
  };

  // Log-scale sliders for thermodynamic and photonic computing multipliers
  const logSliders = {
    thermoGroundMult: { p: 'thermoGroundMult', min: 2, max: 4 }, // 10^2 to 10^4
    thermoSpaceMult: { p: 'thermoSpaceMult', min: 2, max: 5 },   // 10^2 to 10^5
    photonicGroundMult: { p: 'photonicGroundMult', min: 1, max: 3 }, // 10^1 to 10^3
    photonicSpaceMult: { p: 'photonicSpaceMult', min: 1, max: 4 }    // 10^1 to 10^4
  };
  Object.entries(logSliders).forEach(([id, cfg]) => {
    const el = document.getElementById(id);
    const val = document.getElementById('v-' + id);
    if (!el) return;
    // INITIALIZE from slider value on page load
    P[cfg.p] = Math.pow(10, parseFloat(el.value));
    if (val) val.textContent = Math.round(P[cfg.p]);
    // Also update on change
    el.addEventListener('input', () => {
      P[cfg.p] = Math.pow(10, parseFloat(el.value));
      if (val) val.textContent = Math.round(P[cfg.p]);
      update();
    });
  });
  
  Object.entries(sliders).forEach(([id, cfg]) => {
    const el = document.getElementById(id);
    const val = document.getElementById('v-' + id);
    if (!el) return;
    // INITIALIZE from slider value on page load
    P[cfg.p] = parseFloat(el.value) * cfg.s;
    if (val) val.textContent = cfg.f(P[cfg.p]);
    // Also update on change
    el.addEventListener('input', () => {
      P[cfg.p] = parseFloat(el.value) * cfg.s;
      if (val) val.textContent = cfg.f(P[cfg.p]);
      update();
    });
  });
  
  document.querySelectorAll('.tab').forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      document.querySelector(`.tab-panel[data-tab="${tab.dataset.tab}"]`).classList.add('active');
    });
  });

  // DEBUG: Log params after initialization
  console.log('=== PARAMS AFTER INIT ===');
  console.log('Sliders:', {
    radLearn: P.radLearn,
    solarEff: P.solarEff,
    solarLearn: P.solarLearn,
    prodMult: P.prodMult,
    maintCost: P.maintCost,
    bwCost: P.bwCost,
    gbpsPerTflop: P.gbpsPerTflop
  });
  console.log('Thermo/Photonic:', {
    thermoOn: P.thermoOn,
    thermoSpaceMult: P.thermoSpaceMult,
    photonicOn: P.photonicOn,
    photonicSpaceMult: P.photonicSpaceMult,
    workloadProbabilistic: P.workloadProbabilistic
  });
  console.log('Fusion/Fission:', {
    fusionOn: P.fusionOn,
    fusionYear: P.fusionYear,
    fissionOn: P.fissionOn,
    fissionYear: P.fissionYear
  });

  update();
});
</script>
</body>
</html>
